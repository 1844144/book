# Шаблонные типы данных, типажи и время жизни

Наверное, каждый прагматичный язык программирования имеет в своём арсенале эффективное средство
борьбы с дублированием кода. В Rust одним из таким средств является концепция
шаблонных типов данных - *generics*. Это абстрактные типы для конкретных типов или
свойств. Когда мы пишем и компилируем код мы можем подставить конкретный тип данных.
Мы можем решать задачи с различными типами данных без учёта их специфики.

Это подобно тому, как функция принимает параметры с неизвестными значениями, чтобы запускать тот же код на множестве конкретных значений. Функции могут принимать параметры некоторого "универсального" типа вместо конкретного, вроде `i32` или `String`. Мы уже использовали такие типы данных в Главе 6 (`Option<T>`), в Главе 8 (`Vec<T>` и `HashMap<K, V>`) и в Главе 9 (`Result<T, E>`). В этой главе мы рассмотрим, как определить наши собственные типы данных, функции, методы, используя возможности шаблонных типов.

Прежде всего, мы рассмотрим механизм получения функции, которая уменьшает дублирование
кода. Далее, мы будем использовать тот же механизм для получения функции с шаблонным
типом данных.  Мы также можем использовать шаблонные типы данных при определении
структур и перечислений.

После этого, мы поговорим о *типажах*. Типажи - это способ определения поведения
в стиле шаблонных типов данных. Типажи могут быть комбинацией шаблонных типов данных
для уменьшения возможных типов данных, которые имеют определённое поведение.

В конце мы обсудим *времена жизни (lifetimes)*, как вариацию шаблонных типов, которая дает компилятору информацию о том, как ссылки относятся друг к другу. Времена жизни позволяют одалживать (borrow) значения во многих ситуациях, предоставляя возможность компилятору удостовериться, что ссылки являются валидными.

## Удаление дублирования кода с помощью выделения функции

Прежде чем перейти к рассмотрению синтаксиса шаблонных типов данных, предлагаю
рассмотреть технику устранения дублирования кода. Поняв механизм устранения дублирования,
применим его для создания шаблонных типов данных.

Рассмотрим небольшую программу, которая ищет наибольшее число в списке (листинг 10-1):

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("Наибольшее число: {}", largest);
#    assert_eq!(largest, 100);
}
```

<span class="caption">Листинг 10-1: Код поиска наибольшего числа в списке</span>

Программа сохраняет вектор целых чисел в переменной `number_list` и помещает первое значение из списка в переменную `largest`. Далее, итератор проходит по всем элементам списка. Если текущий элемент больше числа сохраненного в переменной `largest`, то его значение заменяет значение в этой переменной. Если текущий элемент меньше или равен "наибольшему" найденному ранее, то значение переменной `largest` не изменяется. После полного перебора всех элементов, переменная `largest` должна содержать наибольшее значение, которое в нашем случае будет равно 100.

Чтобы найти наибольшее число в друх различных списках, мы можем дублировать код листинга 10-1 и использовать такую же логику в двух различных местах программы, как показано в листинге 10-2:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("Наибольшее число: {}", largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("Наибольшее число: {}", largest);
}
```

<span class="caption">Листинг 10-2: Программа поиска наибольшего числа в 
<em>двух</em> списках</span>

Несмотря на то, что код программы работает - этот код может содержать ошибки.
Этот код можно улучшить (прежде всего логику его работы).

Для устранения дублирования нам надо создать абстракции с помощью определения функции, которая работает на любом списке целых чисел, который передан в нее входным параметром. Данное решение делает код более ясным и позволяет выразить концепцию поиска наибольшего числа в списке абстрактным образом.

В листинге 10-3, мы извлекли код, который находит наибольшее число, в отдельную функцию с именем `largest`. В отличии от кода в листинге 10-1, который находит наибольшее число только в одном конкретном списке, новая программа может искать наибольшее число в двух разных списках.

<span class="filename">Файл: src/main.rs</span>

```rust
fn largest(list: &[i32]) -> i32 {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("Наибольшее число: {}", result);
#    assert_eq!(result, 100);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("Наибольшее число: {}", result);
#    assert_eq!(result, 6000);
}
```

<span class="caption">Листинг 10-3: Функция поиска наибольшего элемента
в двух списках</span>

Функция `largest` имеет параметр с именем `list`, который представляет любой срез значений типа `i32`, которые мы можем передать в нее. В результате, когда мы вызовем эту функцию, код выполнится с конкретными значениями, переданными в неё.

In sum, here are the steps we took to change the code from Listing 10-2 to
Listing 10-3:

1. Определить дублирующийся код.
2. Выбираем дублирующий код из тела функции. Создаем отдельную функцию с этим кодом.
3. Обновить и заменить два участка дублирующегося кода вызовом функции.

Далее, мы воспользуемся этими же шагами для шаблонных типов, чтобы различными способами уменьшить дублирование кода. Шаблонные типы позволяют работать над абстрактными типами тем же образом, каким тело функции может работать над абстрактным списком `list` вместо конкретных значений.

Например, у нас есть две функции: одна ищет наибольший элемент в срезе значений типа `i32`, а другая в срезе значений типа `char`. Как уменьшить такое дублирование? Давайте выяснять!
