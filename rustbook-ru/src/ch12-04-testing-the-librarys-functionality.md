## Развитие функциональности библиотеки разработкой на основе тестов

Теперь, когда мы извлекли логику в *src/lib.rs* и оставили разбор аргументов командной строки и обработку ошибок в *src/main.rs*, стало гораздо проще писать тесты для основной функциональности нашего кода. Мы можем вызывать функции напрямую с различными аргументами и проверить возвращаемые значения без необходимости вызова нашего двоичного файла из командной строки. Не стесняйтесь самостоятельно написать некоторые тесты для проверки функциональности в `Config::new` и `run`.

В этом разделе в программу `minigrep` мы добавим логику поиска с использованием процесса разработки через тестирование (TDD). Это техника разработки программного обеспечения следует этим шагам:

1. Пишите тест, который не прошел и запустите его, чтобы убедиться, что он не прошел по той причине, которую вы ожидаете.
2. Пишите или изменяйте ровно столько кода, чтобы успешно выполнился новый тест.
3. Модифицируйте код, который вы только что добавили или изменили и убедитесь, что тесты продолжают проходить.
4. Повторите с шага 1!

Этот процесс является лишь одним из многих способов написания программного обеспечения, но TDD также может помочь дизайну кода. Написание теста перед написанием кода, который делает тестовый прогон помогает поддерживать высокое покрытие тестированием в течение всего процесса.

Мы протестируем реализацию функциональности, которая делает поиск строки запроса в содержимом файла и создание списка строк, соответствующих запросу. Мы добавим эту функциональность в функцию под названием `search` .

### Написание теста с ошибкой

Давайте удалим выражения `println!` из *src/lib.rs* и *src/main.rs*, которые мы использовали для проверки поведения программы, поскольку они нам больше не нужны. Затем в *src/lib.rs* мы добавим модуль `tests` с функцией тестирования, так как мы сделали в [главе 11]<comment></comment>. Тест функция задает поведение, которое мы хотим получить у функции `search`: она будет принимать сам запрос, текст для поиска запроса и она будет возвращать только строки из текста содержащих запрос. Листинг 12-15 показывает этот тест, который еще не будет компилироваться.

<span class="filename">Файл: src/lib.rs</span>

```rust
# pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
#      vec![]
# }
#
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(
            vec!["safe, fast, productive."],
            search(query, contents)
        );
    }
}
```

<span class="caption">Листинг 12-15. Создание теста с ошибкой для функции <code>search</code>, которую мы хотели бы получить</span>

Этот тест ищет строку `"duct"`. Текст, в котором мы делаем поиск является тремя строками, только одна из которых содержит `"duct"`. Мы проверяем, что значение возвращаемое из функции `search` содержит только ту строку, которую мы ожидаем.

Мы не можем запустить этот тест и увидеть сбой, потому что тест даже не компилируется: функция `search` еще не существует! Так что мы добавим код, чтобы получить тест для компиляции и запуска, гаписав определение функции `search`, которая всегда возвращает пустой вектор как показано в листинге 12-16. Потом тест должен скомпилироваться и потерпеть неудачу при запуске, потому что пустой вектор не соответствует вектору содержащему строку `"safe, fast, productive."`

<span class="filename">Файл: src/lib.rs</span>

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    vec![]
}
```

<span class="caption">Листинг 12-16. Определение достаточного кода в функции <code>search</code>, чтобы тест скомпилировался</span>

Обратите внимание, что нужно указать явное время жизни `'a` определенное в сигнатуре `search` и использовать её с аргументом `contents` и с возвращаемым значением. Напомним из [Главы 10]<comment></comment>, что параметры времени жизни указывают как время жизни аргумента связано со временем жизни возвращаемого значение. В этом случае мы указываем, что возвращаемый вектор должен содержать срезы строк, которые ссылаются на срезы входного аргумента `contents` (а не аргумента `query` ).

Другими словами, мы говорим Rust, что данные возвращаемые функцией `search` будут жить до тех пор, пока живут данные, переданные в функцию `search` аргументом `contents`. Это важно! Чтобы ссылки были действительными, данные, на которые ссылаются *с помощью* срезов тоже должны быть действительным; если компилятор предполагает, что мы делаем строковые срезы переменной `query`, а не переменной `contents`, он неправильно выполнит проверку безопасности.

Если мы забудем аннотации времени жизни и попробуем скомпилировать эту функцию, мы получим эту ошибку:

```text
error[E0106]: missing lifetime specifier
 --> src/lib.rs:5:51
  |
5 | pub fn search(query: &str, contents: &str) -> Vec<&str> {
  |                                                   ^ expected lifetime
parameter
  |
  = help: this function's return type contains a borrowed value, but the
  signature does not say whether it is borrowed from `query` or `contents`
```

Возможно Rust не может узнать, какой из двух аргументов нам нужен, поэтому нужно сказать ему об этом. Так как `contents` является аргументом, который содержит весь наш текст и мы хотим вернуть части этого текста, которые совпадают по поиску, мы знаем, что `contents` является аргументом, который должен быть связан с возвращаемым значением, используя синтаксис времени жизни.

Другие языки программирования не требуют от вас связывания аргументов с возвращаемыми значениями в сигнатуре. Хотя это может показаться странным, для вас это станет легче через некоторое время. Можете сравнить этот пример из раздела [«Проверка ссылок с временами жизни»](ch10-03-lifetime-syntax.html#validating-references-with-lifetimes)<comment></comment> главы 10.

Запустим тест:

```text
$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
--warnings--
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running target/debug/deps/minigrep-abcabcabc

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
        thread 'tests::one_result' panicked at 'assertion failed: `(left ==
right)`
left: `["safe, fast, productive."]`,
right: `[]`)', src/lib.rs:48:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
```

Отлично. Наш тест не сработал. Этого мы и ожидали.

### Написание кода для прохождения теста

В настоящее время наш тест не проходит, потому что мы всегда возвращаем пустой вектор. Чтобы исправить и реализовать `search`, наша программа должна выполнить следующие шаги:

- Итерация по каждой строке содержимого.
- Проверить, содержит ли строка содержимого строку запроса.
- Если это так, добавить её в список значений, которые мы возвращаем.
- Если это не так, ничего не делать.
- Вернуть список результатов, которые совпали.

Давайте проработаем каждый шаг, начиная с перебора строк.

#### Перебор строк с помощью метода `lines`

В Rust есть полезный метод для построчной итерации строк, удобно названый `lines`, как показано в листинге 12-17. Обратите внимание, код пока не компилируется.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        // do something with line
    }
}
```

<span class="caption">Листинг 12-17: Итерация по каждой строке из <code>contents</code></span>

Метод `lines` возвращает итератор. Мы поговорим об итераторах в разделе [Глава 13]<comment></comment>, но помните, что вы видели этот способ использования итератора в [Листинге 3-5]<comment></comment>, где мы использовали `for` цикл с итератором, чтобы выполнить некоторый код для каждого элемента в коллекции.

#### Поиск в каждой строке текста запроса

Далее мы проверим, содержит ли текущая строка нашу строку запроса. К счастью, у строк есть полезный метод с именем `contains`, который делает это для нас! Добавьте вызов метода `contains` в функции `search`, как показано в листинге 12-18. Обратите внимание, что это все еще не компилируется.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
```

<span class="caption">Листинг 12-18. Добавление функциональности, содержит ли строка строку в <code>query</code></span>

#### Сохранение совпавшей строки

Нам также нужен способ хранить строки, содержащие нашу строку запроса. Для этого, мы можем сделать изменяемый вектор перед циклом `for`, вызывать метод `push` для сохранения `line` в векторе. После цикла `for` мы возвращаем вектор, как показано в листинге 12-19.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
```

<span class="caption">Листинг 12-19. Сохранение совпадающих строк, так что мы можем вернуть их</span>

Теперь функция `search` должна возвратить только те искомые данные, которые содержат `query` и тест должен пройти. Запустим тест:

```text
$ cargo test
--snip--
running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

Наш тест пройден, поэтому мы знаем, что он работает!

На этом этапе, мы могли бы рассмотреть возможности изменения реализации функции поиска при сохранении прохождения тестов поддерживая имеющуюся функциональность. Код в функции поиска не так уж плох, но он не использует некоторые полезные функции итераторов. Вернемся к этому примеру в [главе 13](ch13-02-iterators.html)<comment></comment>, где будем исследовать итераторы подробно и посмотрим, как его улучшить.

#### Использование функции `search` в функции `run`

Теперь, когда функция `search` работает и протестирована, нужно вызвать `search` из нашей функции `run`. Нам нужно передать значение `config.query` и `contents`, которые `run` читает из файла в функцию `search`. Тогда `run` напечатает каждую строку, возвращаемую из `search` :

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    for line in search(&config.query, &contents) {
        println!("{}", line);
    }

    Ok(())
}
```

Мы все еще используем цикл `for` для возврата каждой строки из функции `search` и ее печати.

Теперь вся программа должна работать! Давайте попробуем, сначала со словом, которое должно вернуть ровно одну строчку из стихотворения Эмили Дикинсон «frog»:

```text
$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38 secs
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
```

Здорово! Теперь давайте попробуем слово, которое будет соответствовать нескольким строкам, например «body»:

```text
$ cargo run body poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep body poem.txt`
I’m nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
```

И наконец, давайте удостоверимся, что мы не получаем никаких строк, когда ищем слово, которого нет в стихотворении, например «monomorphization»:

```text
$ cargo run monomorphization poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep monomorphization poem.txt`
```

Отлично! Мы создали собственную мини-версию классического инструмента и научились тому, как структурировать приложения. Мы также немного узнали о вводе и выводе файлов, времени жизни, тестировании и анализе командной строки.

Чтобы завершить этот проект, мы кратко продемонстрируем примеры, как работать с переменными окружения, как печатать в стандартный поток ошибок, оба из которых полезны при написании программы командной строки.


[главе 11]: ch11-01-writing-tests.html#the-anatomy-of-a-test-function
[Главы 10]: ch10-03-lifetime-syntax.html
[Листинге 3-5]: ch03-05-control-flow.html#looping-through-a-collection-with-for
[Глава 13]: ch13-02-iterators.html