## Оператор управления потоком выполнения `match`

В Rust есть весьма мощная конструкция `match`, которая позволяет сравнивать значение с серией шаблонов и затем выполнять код, в зависимости от того, какое значение совпало. Шаблоном могут выступать литералы, имена переменных, постановочные значения и многое другое. В главе 18 будет много рассказано о различных типах шаблонов и что каждый из них делает. Мощь `match` выражается в выразительной синтаксической конструкции и того факта, что компилятор убедится, что все возможные случаи обработаны.

Думайте о выражении `match` как о машине для сортировки монет: монеты скользят вниз по дорожке с отверстиями разного размера вдоль неё и каждая монета проваливается в первое отверстие, в которое она подходит. Таким же образом, значения проходят через каждый шаблон в конструкции `match` и в первом шаблоне с совпадающим значением, попадают в соответствующий блок кода, который будет использован во время выполнения.

Поскольку мы только что упомянули монеты, давайте использовать их в качестве примера, используя `match`! Можно написать функцию, которая возьмёт неизвестную монету Соединенных Штатов и по аналогии со счетной машиной определит, какая это монета и вернет ее значение в центах, как показано в листинге 6-3.

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

<span class="caption">Пример 6-3: перечисление и выражение <code>match</code>, которое использует
значение перечисления в качестве параметров</span>

Давайте разберём `match` в функции `value_in_cents`. Сначала пишется ключевое слово `match` за которым следует выражение, которое в данном случае является значением `coin`. Это выглядит очень похоже на выражение, используемое с `if`, но есть большая разница: с `if` выражение должно возвращать логическое значение, а здесь это может быть любой тип. Тип `coin` в этом примере - перечисление типа `Coin`, объявленное в строке 1.

Далее идут рукава `match`. Рукава состоят из двух частей: шаблон и некоторый код. Здесь первый рукав имеет шаблон, который является значением `Coin::Penny`, затем идет оператор `=>`, который разделяет шаблон и код для выполнения. Код в этом случае - это просто значение `1`. Каждый рукав отделяется от следующего запятой.

When the `match` expression executes, it compares the resulting value against
the pattern of each arm, in order. If a pattern matches the value, the code
associated with that pattern is executed. If that pattern doesn’t match the
value, execution continues to the next arm, much as in a coin-sorting machine.
We can have as many arms as we need: in Listing 6-3, our `match` has four arms.

The code associated with each arm is an expression, and the resulting value of
the expression in the matching arm is the value that gets returned for the
entire `match` expression.

Фигурные скобки обычно не используются, если код рукава короткий, как в листинге 6-3, где каждая рука только возвращает значение. Если необходимо выполнить несколько строк кода в рукаве, можно использовать фигурные скобки. Например, следующий код будет выводить «Lucky penny!» каждый раз, когда метод вызывается со значением `Coin::Penny`, но все равно возвращает последнее значение блока со значением `1`:

```rust
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter,
# }
#
fn value_in_cents(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        },
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

### Шаблоны, которые связываются со значениями

Есть ещё одно полезное качество у рукавов выражения `match`: они могут привязать части значений,  удовлетворяющих шаблону. Этим способом можно извлечь значение из вариантов перечисления.

В качестве примера, давайте изменим один из вариантов перечисления для хранения данных внутри него. С 1999 по 2008 год Соединенные Штаты чеканили 25 центов с различным дизайном на одной стороне для каждого из 50 штатов. Ни одна другая монета не получила дизайна штата, только четверть доллара имела эту дополнительную особенность. Мы можем добавить эту информацию в наш `enum` путем изменения варианта `Quarter` для включения внутрь значения `UsState`, как сделано в листинге 6-4.

```rust
#[derive(Debug)] // So we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // ... etc
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
```

<span class="caption">Пример 6-4: Перечисление <code>Coin</code>, где одно из значений <code>Quarter</code>
содержит значение перечисления <code>UsState</code></span>

Let’s imagine that a friend of ours is trying to collect all 50 state quarters.
While we sort our loose change by coin type, we’ll also call out the name of
the state associated with each quarter so if it’s one our friend doesn’t have,
they can add it to their collection.

В выражении match для этого кода, мы добавляем переменную с именем `state` в шаблон, который соответствует значениям варианта `Coin::Quarter`. Когда `Coin::Quarter` совпадает, то переменная `state` будет привязана к значению штата четвертной. Затем мы можем использовать `state` в коде для этого рукава, вот так:

```rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}

fn main() {
    value_in_cents(Coin::Quarter(UsState::Alaska));
}
```

Если бы мы сделаем вызов как `value_in_cents(Coin::Quarter(UsState::Alaska))`, то `coin` будет иметь значение `Coin::Quarter(UsState::Alaska)`. Когда мы сравниваем это значение с каждым из рукавов, ни одно из них не совпадёт пока мы не достигнем варианта `Coin::Quarter(state)`. В этой точке привязка для переменной `state` будет иметь значение из перечисления равное `UsState::Alaska`. Можно затем использовать эту привязку в выражении `println!`, получая внутреннее значение состояния из типа `Coin` варианта перечисления `Quarter`.

### Использования перечисления `Option<T>` в конструкции match

В предыдущем разделе мы хотели получить внутреннее значение `T` для случая `Some` при использовании `Option<T>`; мы можем обработать тип `Option<T>` используя `match`, как уже делали с перечислением `Coin`! Вместо сравнения монет мы сравним варианты `Option<T>`, но так что работа  выражения `match` остается такой же.

Let’s say we want to write a function that takes an `Option<i32>` and, if
there’s a value inside, adds 1 to that value. If there isn’t a value inside,
the function should return the `None` value and not attempt to perform any
operations.

Пример использования `match` и `Option<T>` 6-5:

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    println!("{:?}", five);
    println!("{:?}", six);
    println!("{:?}", none);
}
```

<span class="caption">Listing 6-5: A function that uses a <code>match</code> expression on
an <code>Option<i32></code></span>

Давайте рассмотрим первое выполнение `plus_one` более подробно. Когда мы вызываем `plus_one(five)`, то переменная `x` в теле `plus_one` будет иметь значение `Some(5)`. Затем мы сравниваем ее с каждым рукавом match выражения.

```rust,ignore
None => None,
```

Значение `Some(5)` не соответствует шаблону `None`, поэтому мы продолжаем со следующего рукава.

```rust,ignore
Some(i) => Some(i + 1),
```

Совпадает ли `Some(5)` шаблоном `Some(i)`? Да, это так! У нас такой же вариант. Тогда переменная `i` привязывается к значению, содержащемуся внутри `Some`, поэтому `i` получает значение `5`. Затем выполняется код в данном рукаве, поэтому мы добавляем 1 к значению `i` и создаем новое значение `Some` со значением `6` внутри.

Now let’s consider the second call of `plus_one` in Listing 6-5, where `x` is
`None`. We enter the `match` and compare to the first arm.

```rust,ignore
None => None,
```

Оно совпадает! Там нет значения для добавления к нему, поэтому программа останавливается и возвращает значение `None` с правой стороны `=>`. Так как первый рукав совпал, то никакие другие рукава не сравниваются.

Комбинирование `match` и перечислений полезно во многих ситуациях. Вы увидите этот шаблон в коде Rust `match` с перечислением, привязка переменной к данным внутри, а затем выполнение кода на его основе. Сначала это немного сложно, но как только вы привыкнете то захотите чтобы такая возможность была бы во всех языках. Это неизменно любимый пользователями прием.

### Перебор всех значений

Есть еще один аспект выражения `match`, который необходимо обсудить. Рассмотрим версию нашей функции `plus_one`, которая имеет ошибку и не будет компилироваться:

```rust,ignore,does_not_compile
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
```

Мы не обработали вариант `None`, поэтому этот код вызовет дефект в программе. К счастью, Rust знает и умеет ловить такой случай. Если мы попытаемся скомпилировать такой код, мы получим ошибку компиляции:

```text
error[E0004]: non-exhaustive patterns: `None` not covered
 -->
  |
6 |         match x {
  |               ^ pattern `None` not covered
```

Rust знает, что мы не обработали все возможные случаи, и даже знает какие образцы мы забыли! Сравнение по шаблону в Rust является *полными и исчерпывающими*: мы должны обработать до конца все возможности, чтобы код был корректным. Особенно в случае `Option<T>`, когда Rust не позволит нам забыть явно обработать случай `None` и защитит нас от предположения, что у нас есть значение, хотя мы могли бы иметь null, таким образом допуская ошибку на миллиард долларов, рассмотренную ранее.

### Использование `_`

В Rust также есть шаблон, который можно использовать, когда не хочется перечислять все возможные значения. Например, `u8` может иметь допустимые значения от 0 до 255. Если мы только заботимся о значениях 1, 3, 5 и 7 и не хотим перечислять 0, 2, 4, 6, 8, 9 вплоть до 255, то к счастью нам это не нужно. Вместо этого можно использовать специальный шаблон `_`:

```rust
let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
}
```

Шаблон с заполнителем `_` будет соответствовать любому значению. Поместив его после наших других рукавов, рукав с заполнителем `_` будет соответствовать всем возможным случаям, которые не были указаны ранее. Так как `()` это просто значение единичного типа, то в случае `_` ничего не произойдет. В результате можно сказать, что мы хотим ничего не делать для всех возможных значений, которые мы не обработали в  списке перед `_` заполнителем.

Тем не менее, выражение `match` может быть несколько многословным в ситуации, в которой важен только `один` из случаев. Для этой ситуации Rust предоставляет `if let` выражение.
