## Дополнение А: Ключевые слова

Ключевые слова - это словарь языка программирования Rust слова. Данные слова
используются для описания ваших программ и не могут быть использованы в качестве
идентификаторов (имён функций (fn), переменных (let), параметров, имена полей
структур, модулей (mod), контейнеров (crate), констант (const), макросов,
статических переменных (static), атрибутов, типов, типажей (trait)).

### Ключевые слова языка программирования Rust

Следующие ключевые слова имеют описанную функциональность.

- `as` - простое приведение типа, устранение неоднозначности реализованного для элемента трейта, или переименование элементов в `use` и `extern crate`
- `break` - немедленное прекращение цикла
- `const` - обозначение константы
- `continue` - прекратить текущую итерацию цикла и перейти к следующей
- `crate` - внешнее связывание или обозначение макро переменной компонента
- `dyn` - динамическая диспетчеризация для трейт-объектов
- `else` - альтернатива для `if` и `if let`
- `enum` - определение перечисления
- `extern` - определение использования внешнего компонента, функции или связывания
- `false` - логический литерал ЛОЖЬ
- `fn` - определение функции и ссылочной переменной на переменную типа функция
- `for` - итератор
- `if` - оператор сравнения
- `impl` - наследование и реализация типажа
- `in` - часть синтаксической конструкции итератора `for`
- `let` - определение переменной
- `loop` - итератор бесконечного цикла
- `match` - шаблонный селектор
- `mod` - оператор определения модуля
- `move` - оператор перемещения кучи, передача прав
- `mut` -  обозначение возможности изменения переменной
- `pub` - обозначение уровня доступа к структуре, блоку, модулю, `impl` блокам
- `ref` - ссылочное связывание
- `return` - оператор возврата из функции
- `Self` - тип псевдонима для типа реализации типажа
- `self` - заголовок метода или текущего модуля
- `static` - обозначение глобальной переменной или переменной, которая будет доступна на протяжении работы программы
- `struct` - определение структуры
- `super` - обозначение ссылки на родительский модуль относительно текущего
- `trait` - обозначение типажа
- `true` - логический литерал ПРАВДА
- `type` - псевдоним типа и оператор его определения
- `unsafe` - определение небезопасного кода, функции, типажа и реализаций
- `use` - оператор импорта
- `where` - оператор условия
- `while` - логический итератор

### Зарезервированные ключевые слова для будущего использования

Хотя эти не ключевые слова языка программирования Rust, они, возможно, будут
использоваться в новых его версиях.

- `abstract`
- `async`
- `await`
- `become`
- `box`
- `do`
- `final`
- `macro`
- `override`
- `priv`
- `try`
- `typeof`
- `unsized`
- `virtual`
- `yield`

### Сырые идентификаторы

*Сырые идентификаторы* - это синтаксис, позволяющий 
вам использовать ключевые слова там, где обычно они не могут 
быть. Для создания и использования сырого идентфикатора, к 
ключевому слову добавляется префикс `r#`.

Например, ключевое слово `match`. Если вы попытаетесь скомпилировать следующую функцию, использующую в качестве имени `match`:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

вы получите ошибку:

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

Ошибка говорит о том, что вы не можете использовать ключевое 
слово `match` в качестве идентификатора функции. 
Чтобы сделать это `match`, вам нужно использовать 
синтаксис сырых идентификаторов, как здесь:

<span class="filename">Имя файла: src/main.rs</span>

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

Этот код скомпилируется без ошибок. Обратите внимание, что 
префикс `r#` у имени функции указан и в месте её 
вызова в `main`, и в её объявлении.

Сырые идентификаторы позволяют вам использовать любые слова 
в качестве идентификатора, даже если это зарезервированное 
ключевое слово. В дополнение, сырые идентификаторы позвляют 
вам использовать библиотеки, написанные на отличной от 
исползуемой вами редации Rust. Например, `try` 
является ключевым словом в 2018 редакции, но не в 2015. Если вы 
зависите от библиотеки, написанной с использованием 2015 
редакции и имеющей функцию `try`, то для вызова 
такой функции из код 2018 редакции, вам необходимо 
использовать синтаксис сырых идентификаторов, в данном случае 
`r#try`. Редакции расмотрены более детально в 
["Приложении Е"]<comment>.</comment>


["Приложении Е"]: #raw-identifiers