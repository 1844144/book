## Небезопасный Rust

Во всех предыдущих главах этой книги мы обсуждали код написанный в Rust, который гарантирует безопасность памяти во время компиляции. Однако внутри Rust скрывается другой язык, - небезопасный Rust, которые не обеспечивает безопасной работы с памятью. Этот язык называется *unsafe Rust* и работает также как и первый, но предоставляет вам дополнительные возможности.

Небезопасный Rust существует, потому что по своей природе статический анализ является консервативным. Когда компилятор пытается определить, поддерживает ли код некоторые гарантии или нет, то лучше отклонить некоторые действительные программы, которые корректны, чем принимать некоторые программы, которые ошибочны. Бывают случаи, когда ваш код может быть правильным, но Rust считает что это не так. В этих случаях вы можете использовать небезопасный код, чтобы сообщить компилятору: «поверь мне, я знаю, что я делаю». Недостатком является то, что вы используете его на свой страх и риск; если вы используете не безопасный код неправильно, могут появиться проблемы из-за небезопасной работы с памятью, такие как нулевой указатель при разыменовании.

Есть ещё одна причина, по которой Rust имеет небезопасный код: базовое аппаратное обеспечение компьютеров по своей сути небезопасно. Если Rust не позволил бы вам делать небезопасные операций, вы не смогли бы сделать некоторые задачи. Но в Rust необходимо позволять выполнять низкоуровневые системные операции, например, напрямую взаимодействовать с вашей операционной системой или даже писать собственные системы! Работа с низкоуровневым системным программированием является одной из целей языка. Давайте рассмотрим, что мы можем сделать с помощью небезопасного Rust и как.

### Небезопасные сверхспособности

Чтобы переключиться на небезопасный Rust, используйте ключевое слово `unsafe` и начните новый блок, содержащий небезопасный код. Вы можете совершить четыре действия в небезопасном Rust коде, называемом *небезопасными сверхспособностями* , которые вы не можете сделать в безопасном Rust. Эти сверхспособности включают в себя возможность:

- Разыменование сырого указателя
- Вызов небезопасной функции или метода
- Доступ или изменение изменяемой статической переменной
- Реализация небезопасного типажа
- Доступ полей `union`

Важно понимать, что `unsafe` не отключает проверку заимствования или любые другие проверки безопасности Rust: если вы используете ссылку в небезопасной код, она всё равно будет проверена. Единственное, что делает ключевое слово `unsafe` даёт вам доступ к этим четырём функциям, которые не проверяются компилятором для безопасности памяти. Вы по-прежнему получаете некоторую степень безопасности внутри небезопасного блока!

Кроме того, `unsafe` не означает, что код внутри блока обязательно опасен или будет иметь проблемы с безопасностью памяти: цель состоит в том, что вы, как программист гарантируете, что код внутри блока `unsafe` будет обращаться к действительной памяти корректным образом.

Люди подвержены ошибкам и ошибки будут случаться, но требуя чтобы эти четыре небезопасные операции находились внутри блоков помеченных как `unsafe`, вы будете знать, что любые ошибки, связанные с безопасностью памяти, должны находиться внутри `unsafe` блока. Держите `unsafe` блоки маленькими, так вы будете благодарны позже, когда будете исследовать ошибки памяти.

Чтобы максимально изолировать небезопасный код, рекомендуется заключить небезопасный код в безопасную абстракцию и предоставить безопасный API, который мы обсудим, когда будем обсуждать небезопасные функции и методы. Части стандартной библиотеки реализованы как безопасные абстракции над небезопасным кодом, которые были проверены. Оборачивание небезопасного кода в безопасную абстракцию предотвращает использования `unsafe` кода от утечки во всех места, где вы или ваши пользователи могут захотеть использовать функциональность, реализованную кодом `unsafe`, потому что использование безопасной абстракции является безопасным.

Давайте поговорим о каждой из четырёх небезопасных сверхспособностях, и по пути мы рассмотрим некоторые абстракции, которые обеспечивают безопасный интерфейс для небезопасного кода.

### Разыменование сырых указателей

Рассмотрим материал главы 4 ещё раз. Там мы говорили о ссылках. Мы изучили, что компилятор всегда проверяет действительность ссылок. Небезопасный Rust предоставляет два новых типа для работы со ссылками. Также как ссылки, мы имеет изменяемые и неизменяемые указатели (`*const T` и `*mut T`). В контексте сырых ссылок "неизменяемость" значит, что указателям нельзя присваивать значения непосредственно после разыменования.

Отличия сырых ссылок от умных указателей:

- разрешается игнорирование правил заимствования, можно иметь изменяемые и неизменяемы указатели или множество указателей на одну и ту же область памяти.
- нет гарантии действительности указателя
- возможность иметь null-ссылки
- нет реализации автоматической очистки памяти

Отказавшись от необходимости применять эти гарантии, вы можете отказаться от гарантированной безопасности в обмен на большую производительность или возможность взаимодействия с другим языком или оборудованием, где гарантии Rust не применяются.

Листинг 19-1 демонстрирует, как создавать сырые ссылки из обычных ссылок:

```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
```

<span class="caption">Листинг 19-1: создание сырых ссылок из ссылок</span>

Обратите внимание, что мы не включаем ключевое слово `unsafe` в этот код. Мы можем создавать сырые указатели в безопасном коде; мы просто не можем разыменовать сырые указатели за пределами небезопасного блока, как вы увидите чуть позже.

Мы создали сырые указатели, используя `as` для приведения неизменяемой и изменяемой ссылки в соответствующие им типы сырых указателей. Поскольку мы создали их непосредственно из ссылок, которые гарантированно являются действительными, мы знаем, что эти конкретные сырые указатели являются действительными, но мы не можем сделать такое предположение о каком-либо сыром указателе.

Далее мы создадим сырой указатель, в достоверности которого мы не можем быть так уверены. В листинге 19-2 показано, как создать сырой указатель на произвольное место в памяти. Попытка использовать произвольную память не определена: могут быть данные по этому адресу или их нет, компилятор может оптимизировать код, чтобы не было доступа к памяти, или программа может выдать ошибку с ошибкой сегментации. Обычно нет веских причин для написания такого кода, но это возможно.

```rust
let address = 0x012345usize;
let r = address as *const i32;
```

<span class="caption">Листинг 19-2: создание сырых указателей на определённый адрес памяти</span>

Обратите внимания, что в приведённых примерах нет блока `unsafe`. Вы можете *создать* сырые указатели в безопасном коде, но вы не можете разыменовать их или прочесть данные. Использование оператора разыменования сырых указателей разрешается только в блоке `unsafe`:

```rust,unsafe
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;

unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
}
```

<span class="caption">Листинг 19-3: разыменование сырых указателей в блоке <code>unsafe</code></span>

Создание указателей разрешено. Только при попытке доступа к объекту могут быть какие-либо проблемы.

Также обратите внимание, что в примерах кода 19-1 и 19-3 мы создали `*const i32` и `*mut i32`, которые ссылаются на одну и ту же область памяти. Если мы попытаемся создать неизменяемую и изменяемую ссылку на `num` вместо сырых указателей, такой код не скомпилируется, т.к. будут нарушены правила наличия изменяемых и неизменяемых ссылок. С помощью сырых указателей мы можем создать изменяемый указатель и неизменяемый указатель на одну и ту же область памяти и изменять данные с помощью изменяемого указателя, потенциально создавая эффект гонки. Будьте осторожны!

Если существует столько возможных неприятностей, для чего же нужны эти сырые ссылки?! Одно весьма важное их свойство - это возможность быть интерфейсом кода на С. Другим вариантом использования является создание безопасных абстракций, которых не сможет понять система проверки заимствования. Далее мы рассмотрим небезопасные функции, где мы познакомимся с примером использования безопасных абстракций, которые используют небезопасный код.

### Вызов небезопасной функции или метода

Второй тип операции, который требует небезопасного блока, - это вызов небезопасных функций. Небезопасные функции и методы выглядят точно так же, как обычные функции и методы, но они имеют дополнительные `unsafe` перед остальной частью определения. Ключевое слово `unsafe` в этом контексте указывает, что у функции есть требования, которые мы должны соблюдать при вызове этой функции, потому что Rust не может гарантировать, что мы выполнили эти требования. Вызывая небезопасную функцию в `unsafe` блоке, мы говорим, что прочитали документацию по этой функции и несём ответственность за соблюдение контрактов этой функции.

Вот небезопасная функция с именем `dangerous` которая ничего не делает в своём теле:

```rust,unsafe
unsafe fn dangerous() {}

unsafe {
    dangerous();
}
```

Если мы попытаемся вызвать функцию `dangerous` без блока `unsafe`, мы получим ошибку:

```text
error[E0133]: call to unsafe function requires unsafe function or block
 --> <anon>:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
```

Вставив `unsafe`-блок вокруг вызова функции `dangerous`, мы сообщаем компилятору, что мы понимаем, что используем небезопасную функцию, мы знаем как её использовать правильным образом и мы соблюли все необходимые условия.

Тела небезопасных функций являются фактически `unsafe` блоками, поэтому для выполнения других небезопасных операций внутри небезопасной функции нам не нужно добавлять ещё один `unsafe` блок.

#### Создание безопасных абстракций вокруг небезопасного кода

Тот факт, что функция содержит небезопасный код, не означает, что мы должны пометить всю функцию как небезопасную. Фактически, упаковка небезопасного кода в безопасную функцию является обычной абстракцией. В качестве примера давайте изучим функцию из стандартной библиотеки `split_at_mut`, для которой требуется небезопасный код и как мы можем её реализовать. Этот безопасный метод определён для изменяемых фрагментов: он берёт один фрагмент и делит его на два, разделяя фрагмент по индексу, указанному в качестве аргумента. В листинге 19.4 показано, как использовать `split_at_mut`.

```rust
let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &mut [1, 2, 3]);
assert_eq!(b, &mut [4, 5, 6]);
```

<span class="caption">Листинг 19-4: использование безопасной функции <code>split_at_mut</code></span>

Эту функцию нельзя реализовать, используя только безопасный Rust. Попытка реализации может выглядеть примерно так (19-5). Для просторы мы реализуем функцию, а не метод и только для целых чисел:

```rust,ignore,does_not_compile
fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();

    assert!(mid <= len);

    (&mut slice[..mid],
     &mut slice[mid..])
}
```

<span class="caption">Листинг 19-5: попытка реализации функции <code>split_at_mut</code></span>

Эта функция сначала получает общую длину среза. Затем он утверждает, что индекс, заданный в качестве параметра, находится внутри среза, проверяя, меньше ли он или равен длине. Утверждение означает, что если мы передадим индекс, который больше, чем длина, на которую будет разделён фрагмент, функция будет паниковать, прежде чем попытаться использовать этот индекс.

Затем мы возвращаем два изменяемых фрагмента в кортеже: один от начала исходного фрагмента до `mid` индекса, а другой - от `mid` до конца фрагмента.

При попытке компиляции данной функции вы получите следующее сообщение об ошибке:

```text
error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --> <anon>:6:11
  |
5 |     (&mut slice[..mid],
  |           ----- first mutable borrow occurs here
6 |      &mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
7 | }
  | - first borrow ends here
```

Компилятор не понимает, что вы хотите получить различные части среза, он понимает лишь то, что вы хотите осуществить заимствование дважды. Заимствование различных частей среза не вызывает ошибок компиляции, но всё же это не является лучшим решением.

Листинг 19-6 демонстрирует, как можно использовать `unsafe` блок, сырой указатель и вызов небезопасной функции для реализации целей функции `split_at_mut`:

```rust,unsafe
use std::slice;

fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid <= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
```

<span class="caption">Листинг 19-6: использование небезопасного кода для реализации <code>split_at_mut</code></span>

Напомним, из [«Тип срез»] <comment></comment> в главе 4, где срезы - это указатель на некоторые данные и длину среза. Мы используем метод `len` для получения длины фрагмента и метод `as_mut_ptr` для доступа к сырому указателю фрагмента. Поскольку у нас есть изменяемый фрагмент для значений `i32`, `as_mut_ptr` возвращает сырой указатель с типом `*mut i32`, который мы сохранили в переменной `ptr`.

Мы сохраняем утверждение, что `mid` индекс находится внутри среза. Затем мы обращаемся к небезопасному коду: функция `slice::from_raw_parts_mut` принимает сырой указатель и длину и создаёт срез. Мы используем эту функцию, чтобы создать срез, начинающийся с `ptr` и имеющий длину в `mid`. Затем мы вызываем метод `offset` для `ptr` с `mid` в качестве аргумента, чтобы получить сырой указатель, который начинается в `mid`, и мы создаём срез, используя этот указатель и оставшееся количество элементов после `mid` в качестве длины.

Функция `slice::from_raw_parts_mut` небезопасна, потому что она принимает сырой указатель и должна верить, что этот указатель действителен. Метод `offset` в сырых указателях также небезопасен, поскольку он должен полагать, что местоположение смещения также является допустимым указателем. Поэтому нам пришлось поместить `unsafe` блок вокруг наших вызовов `slice::from_raw_parts_mut` и `offset` чтобы мы могли их вызвать. Посмотрев на код и добавив утверждение, что `mid` должно быть меньше или равно `len`, мы можем сказать, что все сырые указатели, используемые в `unsafe` блоке, будут действительными указателями на данные внутри среза. Это приемлемое и правильное использование `unsafe`.

Обратите внимание, что нам не нужно помечать результирующую функцию `split_at_mut` как `unsafe`, и мы можем вызвать эту функцию из безопасного Rust. Мы создали безопасную абстракцию небезопасного кода с помощью реализации функции, которая использует `unsafe` код, поскольку она создаёт только допустимые указатели из данных, к которым эта функция имеет доступ.

В отличии от функции `slice::from_raw_parts_mut` код 19-7 скорей всего не будет работать. Этот код получает данные по адресу памяти и создаёт срез длинной 10000:

```rust,unsafe
use std::slice;

let address = 0x012345usize;
let r = address as *mut i32;

let slice = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
```

<span class="caption">Листинг 19-7: создание среза по адресу памяти</span>

Мы не владеем памятью в этом произвольном месте, и нет никакой гарантии, что срез, который создаёт этот код содержит действительные значения `i32`. Попытка использовать `slice` как если бы он был допустимым, приводит к неопределённому поведению.

#### `extern` функции вызывающие внешний код являются небезопасными

Иногда появляется необходимость вызвать код написанный на другом языке программирования. Для этой цели существует специальное ключевое слов `extern`, которое облегчает создание и использование *интерфейса внешних функций* (*Foreign Function Interface* (FFI)). Код 19-8 демонстрирует, как установить связь с С-функцией `abs`. Функции в блоках `extern` всегда являются небезопасными:

Листинг 19-8 демонстрирует, как настроить интеграцию с функцией `abs` из стандартной библиотеки C. Функции, объявленные внутри `extern` блоков, всегда небезопасны для вызова из кода Rust. Причина в том, что другие языки не обеспечивают соблюдение правил и гарантий Rust, а Rust не может их проверить, поэтому ответственность за безопасность ложится на программиста.

<span class="filename">Файл: src/main.rs</span>

```rust,unsafe
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```

<span class="caption">Листинг 19-8: определение и вызов <code>extern</code>-функции написанной на другом языке программирования</span>

С помощью блока `extern "C"` мы сообщаем какую функцию мы хотим вызвать. `"C"` определяет интерфейс какого языка будет использован *application binary interface* (ABI). Наиболее часто используемым интерфейсом является интерфейс языка C.

> #### Вызов функций Rust из других языков программирования
> Ключевое слово `extern` также используется для создания интерфейса, который позволяет вызывать функции Rust из других языков программирования. Вместо блока `extern` мы можем добавить к описанию функции это ключевое слово. Также необходимо добавить аннотацию `#[no_mangle]`, чтобы сообщить компилятору не анализировать данную функцию. В следующем примере функция `call_from_c` будет доступна для кода языка программирования Си (С):
> В следующем примере мы делаем функцию `call_from_c` доступной из кода C, после того как она скомпилирована в общую библиотеку и скомпонована из C:
> ```rust
> #[no_mangle]
> pub extern "C" fn call_from_c() {
>     println!("Just called a Rust function from C!");
> }
> ```
> Использование `extern` не требует использования `unsafe`

### Получение доступа и внесение изменений в изменяемую статическую переменную

Рассказывая о возможностях языка мы ещё ни разу не упомянули о глобальных переменных. Множество языков программирования поддерживают такую возможность. Этот функционал несёт в себе потенциальные проблемы, например, если в многопоточной среде вы будете получать доступ к такой переменной, то может возникнуть эффект гонки.

Глобальные переменные в Rust называют *статическими* (*static*). Код 19-9 демонстрирует определение и использование статической переменной имеющий тип строковый срез:

<span class="filename">Файл: src/main.rs</span>

```rust
static HELLO_WORLD: &str = "Hello, world!";

fn main() {
    println!("name is: {}", HELLO_WORLD);
}
```

<span class="caption">Листинг 19-9: определение и использование неизменяемой статической переменной</span>

`static` переменные походи на константы. Их имена по договорённости также необходимо писать с большой буквы `SCREAMING_SNAKE_CASE`. Кроме того у таких переменных обязательно необходимо (*must*) указывать тип. В данном случае это `&'static str`. Только ссылки с модификатором `'static` могут быть сохранены в статической переменной. По этой причине нет необходимости аннотировать такие переменные модификатором времени жизни.

Доступ к неизменяемым переменным является безопасным. Значения в статических переменных имеют фиксированный адрес в памяти. В отличии от них константам разрешается дублировать свои данные.

Другое отличие статических переменных от констант - они могут быть изменяемыми. Доступ и изменения статических переменных являются небезопасными. Пример кода 19-10 показывает как объявлять, получать доступ и изменять изменяемую статическую переменную `COUNTER`:

<span class="filename">Файл: src/main.rs</span>

```rust,unsafe
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
```

<span class="caption">Листинг 19-10: чтение и запись изменяемой статической переменной</span>

Также как и обычная переменная, статическая переменная может быть изменяемой. Для этого в описании переменной необходимо использовать ключевое слово `mut`. Каждый раз, когда необходим доступ к такой переменной, используется `unsafe`-блок. Данный код компилируется и выводит `COUNTER: 3`. В многопоточной среде при доступе к такой переменной эффект гонок вполне вероятен.

Использование изменяемых статических данных весьма небезопасно. Весьма сложно отслеживать их корректность и защитить от эффекта гонок в многопоточной среде.

### Реализация небезопасных типажей

Последнее действие, которое работает только с `unsafe` заключается в реализации небезопасного типажа. Типаж небезопасен, когда хотя бы один из его методов имеет некоторый инвариант, который компилятор не может проверить. Мы можем объявить, что типаж `unsafe`, добавив ключевое слово `unsafe` перед `trait` и пометив реализацию типажа как `unsafe`, как показано в листинге 19-11.

```rust,unsafe
unsafe trait Foo {
    // объявление метода
}

unsafe impl Foo for i32 {
    // реализация метода
}
```

<span class="caption">Листинг 19-11: определение и реализация небезопасного типажа</span>

Также как и небезопасные функции, методы в небезопасных типажах могут быть небезопасны поэтому их реализации также помечаются `unsafe`

As an example, recall the `Sync` and `Send` marker traits from Chapter 16, and that the compiler implements these automatically if our types are composed entirely of `Send` and `Sync` types. If we implement a type that contains something that’s not `Send` or `Sync` such as raw pointers, and we want to mark our type as `Send` or `Sync`, that requires using `unsafe`. Rust can’t verify that our type upholds the guarantees that a type can be safely sent across threads or accessed from multiple threads, so we need to do those checks ourselves and indicate as such with `unsafe`.

### Когда использовать небезопасный код

Использование `unsafe` не делает в описанных четырёх случаях не делает код неправильным или подозрительным. Просто к такой код не может быть проанализирован компилятором должным образом и на программиста ложится ответственность за его корректность. Кроме того данная аннотация сужает потенциально опасный код до минимума, что может ускорить процесс поиска ошибки.


[«Тип срез»]: ch04-03-slices.html#the-slice-type