## Небезопасный Rust

Во всех предыдущих главах этой книги мы обсуждали код написанный в Rust, который гарантирует безопасность памяти во время компиляции. Однако внутри Rust скрывается другой язык, - небезопасный Rust, который не обеспечивает безопасной работы с памятью. Этот язык называется *unsafe Rust* и работает также как и первый, но предоставляет вам дополнительные возможности.

Небезопасный Rust существует, потому что по своей природе статический анализ является консервативным. Когда компилятор пытается определить, поддерживает ли код некоторые гарантии или нет, то лучше отклонить некоторые действительные программы, которые корректны, чем принимать некоторые программы, которые ошибочны. Бывают случаи, когда ваш код может быть правильным, но Rust считает что это не так. В этих случаях вы можете использовать небезопасный код, чтобы сообщить компилятору: «поверь мне, я знаю, что я делаю». Недостатком является то, что вы используете его на свой страх и риск. Если вы используете не безопасный код неправильно, то могут появиться проблемы из-за небезопасной работы с памятью, такие как разыменование нулевого указателя.

Другая причина, по которой у Rust есть небезопасное альтер эго, заключается в том, что по существу аппаратное обеспечение компьютера небезопасно. Если Rust не позволит бы вам выполнять небезопасные операции, вы не могли бы выполнить определённые задачи. Rust должен позволить вам использовать системное, низкоуровневое программирование, такое как прямое взаимодействие с операционной системой или даже написание вашей собственной операционной системы. Выполнение низкоуровневого, системного программированием является одной из целей языка. Давайте рассмотрим, что можно делать с небезопасным Rust и как это делать.

### Небезопасные сверхспособности

Чтобы переключиться на небезопасный Rust, используйте ключевое слово `unsafe` и начните новый блок, содержащий небезопасный код. Вы можете совершить четыре действия в небезопасном Rust коде, которые называются *небезопасными сверх способностями* и которые вы не можете выполнить в безопасном Rust. Эти сверх способности включают в себя следующие возможности:

- Разыменование сырого указателя
- Вызов небезопасной функции или небезопасного метода
- Доступ или изменение изменяемой статической переменной
- Реализация небезопасного типажа
- Доступа полей в `union`

Важно понимать, что `unsafe` не отключает проверку заимствования или любые другие проверки безопасности Rust: если вы используете ссылку в небезопасном коде, она всё равно будет проверена. Единственное, что делает ключевое слово `unsafe` даёт вам доступ к этим четырём возможностям, которые не проверяют безопасность памяти компилятором. Вы по-прежнему получаете некоторую степень безопасности внутри небезопасного блока.

Кроме того, `unsafe` не означает, что код внутри этого блока является неизбежно опасным или он точно будет иметь проблемы с безопасностью памяти: цель состоит в том, что вы, как программист гарантируете, что код внутри блока `unsafe` будет обращаться к действительной памяти корректным образом.

Люди подвержены ошибкам и ошибки будут происходить, но требуя размещение этих четырёх небезопасных операции внутри блоков помеченных как `unsafe`, вы будете знать, что любые ошибки связанные с безопасностью памяти, должны находиться внутри `unsafe` блоков. Делайте `unsafe` блоки маленькими, вы будете благодарны этому позже при исследовании ошибок с памятью.

Чтобы максимально изолировать небезопасный код, рекомендуется заключить небезопасный код в безопасную абстракцию и предоставить безопасный API, который мы обсудим позже, когда будем обсуждать небезопасные функции и методы. Части стандартной библиотеки реализованы как проверенные, безопасные абстракции над небезопасным кодом. Оборачивание небезопасного кода в безопасную абстракцию предотвращает возможную утечку использования `unsafe` кода во всех местах, где вы или ваши пользователи могли бы захотеть напрямую использовать функциональность, реализованную `unsafe` кодом, потому что использование безопасной абстракции само безопасно.

Давайте поговорим о каждой из четырёх небезопасных сверх способностях и по ходу дела рассмотрим некоторые абстракции, которые обеспечивают безопасный интерфейс для небезопасного кода.

### Разыменование сырых указателей

В главе 4 раздела ["Недействительные ссылки"](ch04-02-references-and-borrowing.html#dangling-references)<comment></comment> мы упоминали, что компилятор гарантирует, что ссылки всегда действительны. Небезопасный Rust имеет два новых типа, называемых *сырыми указателями* (raw pointers), которые похожи на ссылки. Как и в случае ссылок, сырые указатели могут быть неизменяемыми или изменяемыми и записываться как `*const T` и `*mut T` соответственно. Звёздочка не является оператором разыменования; это часть имени типа. В контексте сырых указателей *неизменяемый* (immutable) означает, что указателю нельзя напрямую присвоить что-то после того как он разыменован.

Сырые указатели отличаются от ссылок и умных указателей:

- разрешается игнорирование правил заимствования с возможностью иметь неизменяемые и изменяемые указатели или множество не изменяемых указателей на одну и ту же область памяти
- нет гарантии ссылки на действительную память
- возможность иметь null-ссылки
- нет реализации автоматической очистки памяти

Отказавшись от необходимости применять эти гарантии, вы можете отказаться от гарантированной безопасности в обмен на большую производительность или возможность взаимодействия с другим языком или оборудованием, где гарантии Rust не применяются.

В листинге 19-1 показано, как создать неизменяемый и изменяемый сырой указатель из ссылок.

```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
```

<span class="caption">Листинг 19-1: Создание сырых указателей из ссылок</span>

Обратите внимание, что мы не включаем ключевое слово `unsafe` в этот код. Можно создавать сырые указатели в безопасном коде; мы просто не можем разыменовывать сырые указатели за пределами небезопасного блока, как вы увидите чуть позже.

Мы создали сырые указатели, используя `as` для приведения неизменяемой и изменяемой ссылки к соответствующим им типам сырых указателей. Поскольку мы создали их непосредственно из ссылок, которые гарантированно являются действительными, мы знаем, что эти конкретные сырые указатели являются действительными, но мы не можем делать такое же предположение о любом сыром указателе.

Далее мы создадим сырой указатель, в достоверности которого мы не можем быть уверены. В листинге 19-2 показано, как создать сырой указатель на произвольный адрес памяти. Попытка использовать произвольную память не определена (undefined): по этому адресу могут быть данные или их может не быть, компилятор может оптимизировать код так, что не будет кода доступа к памяти или программа могла бы выдать ошибку сегментации при выполнении. Обычно нет веских причин для написания такого кода, но это возможно.

```rust
let address = 0x012345usize;
let r = address as *const i32;
```

<span class="caption">Листинг 19-2: Создание сырого указателя на произвольный адрес памяти</span>

Напомним, что можно создавать сырые указатели в безопасном коде, но нельзя *разыменовывать* сырые указатели и читать данные, на которые они указывают. В листинге 19-3 мы используем оператор разыменования `*` для сырого указателя, который требует `unsafe` блока.

```rust,unsafe
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;

unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
}
```

<span class="caption">Листинг 19-3: Разыменование сырых указателей внутри <code>unsafe</code> блока</span>

Создание указателя не является вредным; вред возможен только когда мы пытаемся получить доступ к значению, на которое указывает указатель, что могло бы привести к использованию недопустимого значения.

Также обратите внимание, что в примерах кода 19-1 и 19-3 мы создали `*const i32` и `*mut i32`, которые ссылаются на одну и ту же область памяти, где хранится `num`. Если мы попытаемся создать неизменяемую и изменяемую ссылку на `num` вместо сырых указателей, такой код не скомпилируется, т.к. будут нарушены правила заимствования, запрещающие наличие изменяемой ссылки одновременно с неизменяемыми ссылками. С помощью сырых указателей мы можем создать изменяемый указатель и неизменяемый указатель на одну и ту же область памяти и изменять данные с помощью изменяемого указателя, потенциально создавая эффект гонки данных. Будьте осторожны!

С учётом всех этих опасностей, зачем тогда использовать сырые указатели? Одним из основных применений является взаимодействие с кодом C, как вы увидите в следующем разделе ["Вызов небезопасной функции или метода"](#calling-an-unsafe-function-or-method)<comment></comment>. Другой случай это создание безопасных абстракций, которые не понимает анализатор заимствований. Мы представим небезопасные функции и затем рассмотрим пример безопасной абстракции, которая использует небезопасный код.

### Вызов небезопасной функции или метода

Второй тип операции, который требует небезопасного блока - это вызов небезопасных функций. Небезопасные функции и методы выглядят точно так же, как обычные функции и методы, но они имеют дополнительное указание `unsafe` перед остальной частью определения. Ключевое слово `unsafe` в этом контексте указывает, что у функции есть требования, которые мы должны соблюдать при её вызове, потому что Rust не может гарантировать выполнение этих требований. Вызывая небезопасную функцию в `unsafe` блоке, мы говорим, что прочитали документацию по этой функции и несём ответственность за соблюдение её контрактов.

Вот небезопасная функция с именем `dangerous` которая ничего не делает в своём теле:

```rust,unsafe
unsafe fn dangerous() {}

unsafe {
    dangerous();
}
```

Мы должны вызвать функцию `dangerous` в отдельном `unsafe` блоке. Если мы попробуем вызвать `dangerous` без `unsafe` блока, мы получим ошибку:

```text
error[E0133]: call to unsafe function requires unsafe function or block
 -->
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
```

Вставив `unsafe` блок вокруг нашего вызова `dangerous`, мы утверждаем то, что мы прочитали документацию к функции, мы понимаем как её использовать правильно и мы убедились, что выполняем контракт функции.

Тела небезопасных функций являются фактически `unsafe` блоками, поэтому для выполнения других небезопасных операций внутри небезопасной функции не нужно добавлять ещё один `unsafe` блок.

#### Создание безопасных абстракций вокруг небезопасного кода

Тот факт, что функция содержит небезопасный код, не означает, что мы должны пометить всю функцию как небезопасную. Фактически, упаковка небезопасного кода в безопасную функцию является обычной абстракцией. В качестве примера давайте изучим функцию из стандартной библиотеки `split_at_mut`, для которой требуется небезопасный код и исследуем, как мы могли бы её реализовать. Этот безопасный метод определён для изменяемых срезов: он берёт один срез и делит его на два, разделяя срез по индексу, указанному в качестве аргумента. В листинге 19.4 показано, как использовать `split_at_mut`.

```rust
let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &mut [1, 2, 3]);
assert_eq!(b, &mut [4, 5, 6]);
```

<span class="caption">Листинг 19-4: Использование безопасной функции <code>split_at_mut</code></span>

Эту функцию нельзя реализовать, используя только безопасный Rust. Попытка реализации могла бы выглядеть примерно как в листинге 19-5, который не компилируется. Для просторы мы реализуем `split_at_mut` как функцию, а не как метод, и только для значений типа `i32`, а не обобщённого типа `T`.

```rust,ignore,does_not_compile
fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();

    assert!(mid <= len);

    (&mut slice[..mid],
     &mut slice[mid..])
}
```

<span class="caption">Листинг 19-5: Попытка реализации функции <code>split_at_mut</code> используя только безопасный Rust</span>

Эта функция сначала получает общую длину среза. Затем она утверждает, что индекс, заданный в качестве параметра, находится внутри среза, проверяя меньше он или равен длине. Утверждение означает, что если мы передадим индекс, который больше, чем длина, на которую будет разделён фрагмент, функция будет паниковать до попытки использования индекса.

Затем мы возвращаем два изменяемых фрагмента в кортеже: один от начала исходного фрагмента до `mid` индекса (не включая сам mid), а другой - от `mid` (включая сам mid) до конца фрагмента.

При попытке скомпилировать код в листинге 19-5, мы получим ошибку.

```text
error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 -->
  |
6 |     (&mut slice[..mid],
  |           ----- first mutable borrow occurs here
7 |      &mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
8 | }
  | - first borrow ends here
```

Анализатор заимствований Rust не может понять, что мы заимствуем различные части среза, он понимает лишь то, что мы хотим осуществить заимствование дважды. Заимствование различных частей среза в принципе нормально, потому что две части среза не перекрываются, но Rust недостаточно умён, чтобы это знать. Когда мы знаем, что код в порядке, а Rust этого не знает, то значит пришло время прибегнуть к небезопасному коду.

Листинг 19-6 демонстрирует, как можно использовать `unsafe` блок, сырой указатель и вызовы небезопасных функции для реализации работы `split_at_mut`:

```rust,unsafe
use std::slice;

fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid <= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
```

<span class="caption">Листинг 19-6: Использование небезопасного кода для реализации функции <code>split_at_mut</code></span>

Напомним, из раздела ["Тип срез"]<comment></comment> главы 4, что срезы являются указателями на некоторые данные и длину среза. Мы используем метод `len` для получения длины среза и метод `as_mut_ptr` для доступа к сырому указателю среза. Поскольку у нас есть изменяемый срез на значения типа `i32`, функция `as_mut_ptr` возвращает сырой указатель типа `*mut i32`, который мы сохранили в переменной `ptr`.

Далее утверждаем в коде, что `mid` индекс находится внутри среза. Затем мы обращаемся к небезопасному коду: функция `slice::from_raw_parts_mut` принимает сырой указатель, длину и создаёт срез. Мы используем эту функцию для создания среза, начинающегося с `ptr` и имеющего длину в `mid` элементов. Затем мы вызываем метод `offset` для `ptr` с `mid` в качестве аргумента, чтобы получить сырой указатель, который начинается с `mid`, и создаём срез, используя этот указатель и оставшееся количество элементов после `mid` в качестве длины.

Функция `slice::from_raw_parts_mut` небезопасна, потому что она принимает сырой указатель и должна верить, что этот указатель действителен. Метод `offset` для сырых указателях также небезопасен, поскольку он должен доверять, что местоположение смещения также является допустимым указателем. Поэтому нам пришлось поместить `unsafe` блок вокруг вызовов `slice::from_raw_parts_mut` и `offset`, чтобы мы могли их вызвать. Посмотрев на код и добавив утверждение, что `mid` должно быть меньше или равно `len`, мы можем сказать, что все сырые указатели, используемые в `unsafe` блоке будут действительными указателями на данные внутри среза. Это приемлемое и правильное использование `unsafe`.

Обратите внимание, что нам не нужно помечать результирующую функцию `split_at_mut` как `unsafe`, и мы можем вызвать эту функцию из безопасного Rust. Мы создали безопасную абстракцию для небезопасного кода с помощью реализации функции, которая использует код `unsafe` блока безопасным образом, поскольку она создаёт только допустимые указатели из данных, к которым эта функция имеет доступ.

Напротив, использование `slice::from_raw_parts_mut` в листинге 19-7 приведёт к вероятному сбою при использовании среза. Этот код использует произвольный адрес памяти и создаёт срез из 10000 элементов.

```rust,unsafe
use std::slice;

let address = 0x01234usize;
let r = address as *mut i32;

let slice: &[i32] = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
```

<span class="caption">Листинг 19-7: Создание среза из произвольного адреса памяти</span>

Мы не владеем памятью в этом произвольном месте и нет никаких гарантий что срез, создаваемый этим кодом, содержит допустимые значения `i32`. Попытка использовать переменную `slice` как будто это допустимый срез приводит к неопределённому поведению (UB - undefined behavior).

#### Использование `extern` функций для вызова внешнего кода

Иногда в вашем Rust коде может появиться необходимость взаимодействия с кодом, написанным на другом языке программирования. Для этой цели существует специальное ключевое слов `extern`, которое облегчает создание и использование *интерфейса внешних функций* (FFI - Foreign Function Interface). FFI в языке программирования является способом  определять функции и давать возможность другому (иностранному) языку программирования вызывать эти функции.

Листинг 19-8 демонстрирует, как настроить интеграцию с функцией `abs` из стандартной библиотеки C. Функции, объявленные внутри `extern` блоков, всегда небезопасны для вызова из кода Rust. Причина в том, что другие языки не обеспечивают соблюдение правил и гарантий Rust, Rust также не может проверить гарантии, поэтому ответственность за безопасность ложится на программиста.

<span class="filename">Файл: src/main.rs</span>

```rust,unsafe
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```

<span class="caption">Листинг 19-8: Объявление и вызов <code>extern</code> функции написанной на другом языке программирования</span>

Внутри блока `extern "C"` мы перечисляем имена и сигнатуры внешних функций из другого языка, которые мы хотим вызвать. Часть `"C"` определяет какой *application binary interface* (ABI - бинарный интерфейс приложений) использует внешняя функция. Интерфейс ABI определяет как вызвать функцию на уровне ассемблера. Использование ABI `"C"` является наиболее часто используемым и следует правилам ABI интерфейса языка Си.

> #### Вызов функций Rust из других языков программирования
> Также можно использовать `extern` для создания интерфейса, который позволяет другим языкам вызывать функции Rust. Вместо `extern` блока мы добавляем ключевое слово `extern` и указываем ABI для использования непосредственно перед ключевым словом `fn`. Также нужно добавить аннотацию `#[no_mangle]`, чтобы компилятор Rust не изменял название этой функции. *Искажение* (Mangling) - это когда компилятор подменяет имя нашей функции другим именем, которое содержит больше информации для использования другими этапами процесса компиляции, но такие имена являются менее читабельными. Каждый компилятор языка программирования подменяет имена по своему, поэтому чтобы функция Rust могла быть доступна  из других языков, мы должны отключить искажение имён Rust компилятором.
> В следующем примере мы делаем Rust функцию `call_from_c` доступной из кода C, после того как она скомпилирована в общую библиотеку и скомпонована из C:
> ```rust
> #[no_mangle]
> pub extern "C" fn call_from_c() {
>     println!("Just called a Rust function from C!");
> }
> ```
> Использование `extern` не требует использования `unsafe`

### Получение доступа и внесение изменений в изменяемую статическую переменную

До текущего момента, мы не говорили о *глобальных переменных* (global variables), поддерживаемых языком Rust, но использование которых может быть проблематичным из-за правил заимствования. Если два потока получают доступ к той же самой глобальной переменной, то это может вызвать ситуацию гонки данных.

Глобальные переменные в Rust называют *статическими* (static). Листинг 19-9 демонстрирует пример объявления и использования в качестве значения статической переменной, имеющей тип строковый срез:

<span class="filename">Файл: src/main.rs</span>

```rust
static HELLO_WORLD: &str = "Hello, world!";

fn main() {
    println!("name is: {}", HELLO_WORLD);
}
```

<span class="caption">Листинг 19-9: Определение и использование неизменяемой статической переменной</span>

Статические переменные похожи на константы, которые мы обсуждали в разделе ["Различия между переменными и константами"](ch03-01-variables-and-mutability.html#differences-between-variables-and-constants)<comment></comment> главы 3. Имена статических переменных пишутся в нотации `SCREAMING_SNAKE_CASE` по общему соглашению и мы *должны* указывать тип переменной, который является `&'static str` в этом примере. Статические переменные могут хранить только ссылки со временем жизни `'static`, это означает что компилятор Rust может вывести время жизни и нам не нужно аннотировать его явно. Доступ к неизменяемой статической переменная является безопасным.

Константы и неизменяемые статические переменные могут казаться похожими друг на друга, но тонкая разница в том, что значения в статической переменной имеют фиксированный адрес в памяти. Использование такого значения всегда будет обращаться к одним и тем же данным (по некоторому фиксированному адресу). Константам, с другой стороны, разрешено дублировать свои данные с помощью компилятора при любом их использовании.

Другое различие между статическими переменными и константами в том, что статические переменные могут быть изменяемыми. Доступ и изменение статических переменных является *небезопасным*. Листинг 19-10 показывает как объявлять, получать доступ и изменять изменяемую статическую переменную с именем `COUNTER`:

<span class="filename">Файл: src/main.rs</span>

```rust,unsafe
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
```

<span class="caption">Листинг 19-10: Чтение и запись изменяемой статической переменной является небезопасным</span>

Как и для обычных переменных, мы определяем изменяемость с помощью ключевого слова `mut`. Любой код, который читает или пишет переменную `COUNTER` должен находиться в `unsafe` блоке. Этот код компилируется и печатает `COUNTER: 3` как и следовало ожидать, потому что выполняется в одном потоке. Наличие нескольких потоков с доступом к `COUNTER` приведёт к ситуации гонки данных.

Наличие изменяемых данных, которые доступны глобально, делает трудным гарантии отсутствия гонок данных, поэтому Rust считает изменяемые статические переменные небезопасными. Там где это возможно, предпочтительно использовать принципы многопоточности и умные указатели, ориентированные на многопоточное исполнение, которые мы обсуждали в главе 16, так что компилятор проверяет что обращение к данным, доступным из разных потоков, выполняется безопасно.

### Реализация небезопасных типажей

Последнее действие, которое работает только с `unsafe` заключается в реализации небезопасного типажа. Типаж небезопасен, когда хотя бы один из его методов имеет некоторый инвариант, который компилятор не может проверить. Мы можем объявить типаж как `unsafe`, добавив ключевое слово `unsafe` перед объявлением `trait` и пометив реализацию типажа как `unsafe`, что показано в листинге 19-11.

```rust,unsafe
unsafe trait Foo {
    // здесь объявление методов типажа
}

unsafe impl Foo for i32 {
    // здесь реализация методов типажа
}
```

<span class="caption">Листинг 19-11: Определение и реализация небезопасного типажа</span>

Используя `unsafe impl`, мы даём обещание поддерживать инварианты, которые компилятор не может проверить.

В качестве примера вспомним маркерные типажи `Sync` и `Send`, которые мы обсуждали в разделе <a data-md-type="link" href="ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">"Расширяемый параллелизм с помощью типажей `Sync` и `Send`"</a><comment></comment> главы 16: компилятор реализует эти типажи автоматически, если наши типы полностью состоят из типов `Send` и `Sync`. Если мы реализуем тип, который содержит тип не являющийся `Send` или `Sync`, например, как сырые указатели и мы хотим пометить этот тип как `Send` или `Sync`, то мы должны использовать `unsafe` блок. Rust не может проверить, что наш тип поддерживает гарантии того, что он может быть безопасно отправлен между потоками или безопасно доступен из нескольких потоков; поэтому нам нужно добавить эти проверки вручную и указать это с помощью `unsafe`.

### Когда использовать небезопасный код

Использование `unsafe` для выполнения одного из четырёх действий (супер способностей), которые только что обсуждались, не является ошибочным или не одобренным. Но получить корректный `unsafe` код сложнее, потому что компилятор не может помочь в обеспечении безопасности памяти. Если у вас есть причина использовать `unsafe` код, вы можете сделать это, а наличие явной `unsafe` аннотации облегчает отслеживание источника проблем, если они возникают.


["Тип срез"]: ch04-03-slices.html#the-slice-type