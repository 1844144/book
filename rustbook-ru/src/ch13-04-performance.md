## Сравнение производительности циклов и итераторов

Для определения, какую реализацию лучше всего использовать, нам необходимо знать
скорость работы каждой из этих реализаций функции `search` (использование цикла
`for` или итераторов).

Мы выполнили тест производительности, разместив всё содержимое книги *"Приключения Шерлока Хомса" А. Конан Дойля (“The Adventures of Sherlock Holmes” by Sir Arthur Conan Doyle)* в строку типа `String` и поискали слово "the" в её содержимом. Вот результаты теста функции `search` с использованием цикла `for` и с использованием итераторов:

```text
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```

Версия с использованием итераторов была немного быстрее! Мы не будем приводить
здесь непосредственно код теста, поскольку задача не в том, чтобы доказать,
что решения в точности эквивалентны, а в том, чтобы получить общее представление
о том, как эти две реализации равны в производительности. Для более полного
теста, вам нужно проверить различные тексты разных размеров, разные слова,
слова различной длины и всевозможные другие варианты. Дело в том, что итераторы,
будучи высокоуровневой абстракцией, компилируются примерно в тот же код, как
если бы вы написали его низкоуровневый вариант самостоятельно. Итераторы - это
одна из *абстракций с нулевой стоимостью* (*zero-cost abstractions*) в Rust, под
которой мы подразумеваем, что использование абстракции не накладывает
дополнительных расходов во время выполнения так же, как Бьёрн Страуструп,
дизайнер и разработчик C++, определяет *нулевые накладные расходы*
(*zero-overhead*):

Для более исчерпывающего теста, вам нужно проверить различные тексты разных размеров, разные слова, слова различной длины и всевозможные другие варианты. Дело в том, что итераторы,
будучи высокоуровневой абстракцией, компилируются примерно в тот же код, как если бы вы написали его низкоуровневый вариант самостоятельно. Итераторы - это одна из *абстракций с нулевой стоимостью* (_zero-cost abstractions_) в Rust, под
которой мы подразумеваем, что использование абстракции не накладывает дополнительных расходов во время выполнения. Аналогично тому, как Бьёрн Страуструп, дизайнер и разработчик C++, определяет *нулевые накладные расходы*
(_zero-overhead_) в книге “Foundations of C++” (2012):

> В целом, реализация C++ подчиняется принципу отсутствия накладных расходов: за то, чем вы не пользуетесь, платить не нужно. И далее: тот код, что вы используете, нельзя сделать ещё лучше.

В качестве другого примера приведём код, взятый из аудиодекодера.
Алгоритм декодирования использует математическую операцию линейного предсказания для оценки будущих значений на основе линейной функции предыдущих выборок.
Код использует кобинирование вызовов итератора для выполнения математических вычислений для трёх переменных в области видимости: срез данных `buffer`, массив из 12 коэффициентов `coefficients` и число для сдвига данных в переменной `qlp_shift`. Переменные определены в примере, но не имеют начальных значений. Хотя этот код не имеет большого значения вне контекста, он является кратким, реальным примером того, как Rust переводит идеи высокого уровня в код низкого уровня.

```rust,ignore
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&buffer[i - 12..i])
                                 .map(|(&c, &s)| c * s as i64)
                                 .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
```

Чтобы вычислить значение переменной `prediction`, этот код перебирает каждое из 12 значений в переменной `coefficients` и использует метод `zip` для объединения значений коэффициентов с предыдущими 12 значениями в переменной `buffer`. Затем, для каждой пары мы перемножаем значения, суммируем все результаты и сдвигаем биты вправо на число из переменной `qlp_shift`.

Для вычислений в таких приложениях, как аудиодекодеры, часто требуется производительность. Здесь мы создаём итератор, используя два адаптера, впоследствии потребляющих значение. В какой ассемблерный код будет компилироваться этот код
на Rust? На момент написания этой главы он компилируется в то же самое, что вы написали бы руками. Не существует цикла, соответствующего итерации по значениям в «коэффициентах»`coefficients`: Rust знает, что существует двенадцать итераций, поэтому он «разворачивает» цикл. *Разворачивание* - это оптимизация, которая устраняет издержки кода управления циклом и вместо этого генерирует повторяющийся код для каждой итерации цикла.

Все коэффициенты сохраняются в регистрах, что означает очень быстрый доступ к значениям. Нет никаких проверок границ доступа к массиву во время выполнения.
Все эти оптимизации, которые может применить Rust, делают полученный код
чрезвычайно эффективным.

## Итоги

Замыкания и итераторы - это возможности Rust, вдохновленные идеями
функционального языка программирования. Они помогают способности Rust, четко
выражать высокоуровненвые идеи с низкоуровневой производительностью.
Реализации замыканий и итераторов таковы, что не влияют на производительность
среды выполнения. Это является частью цели Rust, направленной на создание
абстракций с нулевой стоимостью.

Теперь, когда мы улучшили представление кода в нашем проекте, рассмотрим
некоторые опции, которые нам предоставляет `cargo` для публикации нашего кода в репозитории.
