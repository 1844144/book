## Переменные и понятие изменяемости

Как Вы знаете, по умолчанию все Rust-переменные неизменяемые. Это одна из особенностей
(рекомендаций) языка Rust, которая позволяет писать безопасные программы. Также это важно для
решения задач параллельного программирования. При необходимости переменные могут
быть изменяемыми. Давайте рассмотрим преимущества того и другого подхода.

Поведение неизменяемых переменных напоминает поведение константы.
Приведём пример использования этого типа переменной. Давайте создадим новый проект.
Назовём его *variables*: `cargo new --bin variables`.

Потом в созданной папке проекта *variables* откройте исходный файл *src/main.rs* и замените следующим кодом, который пока не будет компилироваться:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

Сохраните код программы и выполните команду `cargo run`. В терминальной строке вы
увидите красноречивое сообщение об ошибке:

```text
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
```

Компилятор продемонстрировал вам свои полезные возможности. Ошибка была найдена.
Пожалуйста, будьте терпеливы! Компилятор - ваш помощник, который помогает делать
программы защищёнными от ошибок насколько это возможно. Из описания ошибки можно
понять что же не так - `попытка присвоить неизменяемой переменной новое значение`.

Описание ошибки дает понять, что причиной является - `попытка присвоить неизменяемой переменной новое значение`, потому что вы попытались назначить второе значение неизменяемой переменной  `x`.

Это важно, что мы получили ошибки во время компиляции, при попытке изменить ранее не изменяемое значение, потому что такая ситуация может привести к дефектам в программе. Если одна часть кода работает с предположением, что данное значение никогда не изменится, а другая часть кода все-таки меняет значение, всегда возможно, что первая часть кода не будет делать того, для чего она была предназначена. Причину дефектов такого рода иногда трудно отследить, после того как изменение произошло, особенно когда вторая часть кода меняет значение только {em0}иногда{/em0}.

In Rust, the compiler guarantees that when you state that a value won’t change,
it really won’t change. That means that when you’re reading and writing code,
you don’t have to keep track of how and where a value might change. Your code
is thus easier to reason through.

Но изменяемость может быть очень полезной. Переменные являются не изменяемыми только по умолчанию. Аналогично как вы делали в главе 2, можно сделать переменные изменяемыми добавлением ключевого слова `mut` перед названием переменной. В дополнение к возможности изменить значение, указание `mut` передает намерение будущим читателям кода, что другие части кода будут изменять значение этой переменной.

Например, изменим *src/main.rs* на следующий код:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

Запустив программу, мы получим результат:

```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

Ключевое слово `mut` позволяет переменой `x` быть инициализированной значением `5`,
а потом изменить своё содержание на другое значение `6`. В некоторых случая такое
поведение переменной может быть безопасным.

Следует учитывать множество дополнительных компромиссов для  предотвращения дефектов. Например, для повышения производительности кода при работе с большими структурами данных, изменение экземпляра на месте может быть быстрее, чем копирование и возврат вновь созданного экземпляра. При небольших структурах данных создание новых экземпляров и запись кода в более функциональном стиле, может оказаться проще для понимания. В таком случае, снижение производительности может быть полезным недостатком в пользу большей ясности кода.

### Различия между переменными и константами

Невозможность изменить значение переменной может напомнить другую концепцию программирования, которая есть в других языках: *константы (constants)*. Подобно не изменяемым переменным, константы являются значениями привязанными к именам, которые не разрешено менять, но есть несколько отличий между константами и не изменяемыми переменными.

Первое, это то что с константами не разрешено использовать `mut`. Константы не являются не изменяемыми по умолчанию — они не изменяемые всегда.

Константы объявляются с помощью ключевого слова `const` вместо ключевого слова `let` и тип значения *должен* быть аннотирован. Мы собираемся объяснить типы и аннотации типов в следующем разделе [“Типы данных”](ch03-02-data-types.html#data-types)<comment>, так что не волнуйтесь про детали сейчас. Просто знайте, что тип нужно всегда аннотировать.</comment>

Константы можно объявить в любой области видимости, включая глобальный. Это делает их удобными для значений, про которые должны знать многие другие части кода.

Последней разницей является то, что константы можно установить только в константное выражение, которое не является результатом вызова функции или любым другим значением, которое можно посчитать только во время выполнения.

Вот пример объявления костанты `MAX_POINTS`. Для объявления констант рекомендуется
использовать заглавные буквы.

```rust
const MAX_POINTS: u32 = 100_000;
```

Константы доступны в своей области видимости. Также они могут скрываться одноименными
константами во вложенной области видимости. Константы доступны в любом месте области видимости.

Наименование не изменяемых значений во всей программе, таких как константа, является удобным способом выразить смысл значения для будущих пользователей кода. Этот помогает иметь только одно место в коде, которое придется обновить, если будет необходимо поменять его значение в будущем.

### Затенение (переменных)

Как вы видели в обучающем материале по угадыванию числа из раздела [“Сравнение предположения с секретным числом”](ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number)<comment> главы 2, можно объявить переменную с тем же именем что была раньше и такая новая переменная затеняет предыдущую.
Rust разработчики говорят, что первая переменная <em data-md-type="emphasis">затенена (shadowed)</em> второй, а значение второй переменной появляется в коде, когда ее используют. Можно затенять переменную, используя тоже самое имя и повторяя использование ключевого слова <code data-md-type="codespan">let</code> как в примере:</comment>

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);
}
```

This program first binds `x` to a value of `5`. Then it shadows `x` by
repeating `let x =`, taking the original value and adding `1` so the value of
`x` is then `6`. The third `let` statement also shadows `x`, multiplying the
previous value by `2` to give `x` a final value of `12`. When we run this
program, it will output the following:

```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
The value of x is: 12
```

Затенение отличается от объявления переменной с помощью `mut`, так как мы получим ошибку компиляции, если случайно попробуем переназначить значение без использования ключевого слова `let`. Используя `let`, можно выполнить несколько превращений над значением, при этом оставляя переменную неизменяемой, после того как все эти превращения завершены.

The other difference between `mut` and shadowing is that because we’re
effectively creating a new variable when we use the `let` keyword again, we can
change the type of the value but reuse the same name. For example, say our
program asks a user to show how many spaces they want between some text by
inputting space characters, but we really want to store that input as a number:

```rust
let spaces = "   ";
let spaces = spaces.len();
```

This construct is allowed because the first `spaces` variable is a string type
and the second `spaces` variable, which is a brand-new variable that happens to
have the same name as the first one, is a number type. Shadowing thus spares us
from having to come up with different names, such as `spaces_str` and
`spaces_num`; instead, we can reuse the simpler `spaces` name. However, if we
try to use `mut` for this, as shown here, we’ll get a compile-time error:

```rust,ignore,does_not_compile
let mut spaces = "   ";
spaces = spaces.len();
```

Ошибка говорит, что не разрешается менять тип переменной:

```text
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &str, found usize
  |
  = note: expected type `&str`
             found type `usize`
```

Теперь, когда вы имеете представление о работе с переменными, посмотрим на большее количество типов данных, которые они могут иметь.
