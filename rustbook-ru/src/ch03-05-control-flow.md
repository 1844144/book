## Управление выполнением кода

Решение выполнять ли ту или иную часть кода, продолжать или нет выполнение некоторого кода циклически, в зависимости от логических условий - это все является базовыми блоками в большинстве языков. 
Наиболее общими конструкциями, позволяющими управлять выполнением кода в Rust являются выражения `if` и циклы.

### Выражения `if`

Выражение `if` позволяет выполнять ветви кода в зависимости от условий. Вы предоставляете условие и затем пишите утверждение, “Если это условие выполняется/верное, выполнить данный блок кода. Если не выполняется, не выполнять этот блок кода”.

Создадим новый проект *branches* и добавим следующий код:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```

Все `if`-выражения начинаются с ключевого слова `if`. Далее следует логическое выражение.
При необходимости, после тела блока `if` может следовать `else`-выражение.

Опционально можно включить выражение `else`, которое мы используем в данном примере, чтобы предоставить программе альтернативный блок выполнения кода, выполняющийся при ложном условии. Если не написать выражение `else` и условие будет ложным, то программа просто пропустит блок `if` и перейдет на следующий далее код.

Попробуйте запустить данный код, вы должны увидеть следующий результат:

```text
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condition was true
```

Попробуем поменять число в значение, которое сделает условие ложным и посмотрим, что будет:

```rust,ignore
let number = 7;
```

Результат работы программы:

```text
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
condition was false
```

Также стоит отметить, что условие в этом коде *должно* быть типом `bool` . Если условие не будет `bool` , то вы получите ошибку. Например, попробуйте запустить следующий код:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}
```

На этот раз условие `if` вычисляется в значение `3` и Rust генерирует ошибку:

```text
error[E0308]: mismatched types
 --> src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected bool, found integer
  |
  = note: expected type `bool`
             found type `{integer}`
```

В Rust нельзя автоматически конвертировать в `bool` тип данных. Исправим ошибку
в коде:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}
```

Будет выведена следующая строка `number was something other than zero`.

#### Использование выражений `else if`

`if`-выражения могут быть достаточно сложными. Например:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

Программа имеет четыре возможных варианта ветвления. После запуска, вы увидите следующий вывод:

```text
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
number is divisible by 3
```

Для кода с большим количеством `else if`-выражений большое подойдёт конструкция `match`.
О ней мы расскажем в главе 6.

Using too many `else if` expressions can clutter your code, so if you have more
than one, you might want to refactor your code. Chapter 6 describes a powerful
Rust branching construct called `match` for these cases.

#### Использование `if` в `let`-операторах

Так как `if` является выражением, то его можно использовать в правой части кода оператора `let`, как в листинге 3-2.

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!("The value of number is: {}", number);
}
```

<span class="caption">Листинг 3-4: Присвоение результата <code>if</code>-выражения переменной при её инициализации</span>

Переменная `number` будет привязана к значению, которое является результатом выражения `if`. Запустим код и посмотрим, что происходит:

```text
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/branches`
The value of number is: 5
```

Обратите внимание, что у данной инициирующей конструкции есть ограничения. Все возвращаемые
значения `if`-выражения должны иметь один тип данных.
Пример:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
fn main() {
    let condition = true;

    let number = if condition {
        5
    } else {
        "six"
    };

    println!("The value of number is: {}", number);
}
```

При попытке компиляции этого кода, мы получим ошибку. Ветви  `if` и `else` имеют не совместимые типы значений и компилятор Rust точно указывает, где находится проблема в программе:

```text
error[E0308]: if and else have incompatible types
 --> src/main.rs:4:18
  |
4 |       let number = if condition {
  |  __________________^
5 | |         5
6 | |     } else {
7 | |         "six"
8 | |     };
  | |_____^ expected integer, found &str
  |
  = note: expected type `{integer}`
             found type `&str`
```

Такое поведение кода делает вашу работу предсказуемой и оберегает от потенциальных
ошибок.

### Повторение выполнения кода с помощью циклов

Довольно часто полезно выполнить блок кода более одного раза. Для такой задачи Rust предоставляет несколько разновидностей *циклов*. Цикл выполняет код внутри тела цикла от начала и до конца, а затем немедленно возвращается обратно в начало. Для экспериментов создадим новый проект с именем *loops*.

Виды циклов: `loop`, `while` и `for`. Рассмотрим каждый в отдельности.

#### Повторение выполнения кода с помощью `loop`

Ключевое слово `loop` указывает Rust выполнять блок кода снова и снова до бесконечности, или пока вы явно не скажете ему остановиться.

В качестве примера, измените код файла *src/main.rs* в каталоге проекта *loops* на код ниже:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    loop {
        println!("again!");
    }
}
```

Остановить выполнения кода можно лишь аварийно завершив работу программы сочетанием
клавиш <span class="keystroke">ctrl-C</span>.

```text
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
```

Существует ключевое слово `break`, благодаря которому можно остановить работу бесконечного
цикла.

Цикл с условием `while` выполняет тело пока выполняется логическое условие параметра.

#### Возврат чисел из цикла

Filename: src/main.rs

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
```

Перед циклом объявлется переменная с именем `counter` и ее значение инициализируется в `0`. Затем объявляется переменная с именем `result` для хранения значения, возвращаемого из цикла. На каждом проходе цикла добавляется `1` к переменной `counter` и затем проверяется, равен ли этот счетчик значению `10`. Если равен, то используется ключевое слово `break` со значением `counter * 2`. После цикла используется точка с запятой в конце операции, которая назначает значение переменной  `result`. В заключении, печатается значение из переменной `result`, которое в данном случае равно 20.

#### Циклы по условию `while`

Часто бывает полезно вычислять условие внутри цикла. Пока условие выполняется, цикл продолжается. Когда условие перестаёт быть истинным, программа вызывает `break` и останавливает цикл. Данный тип цикла может быть реализован используя комбинацию из `loop`, `if`, `else` и `break`. Можете попробовать в программе, если хотите.

Тем не менее, данный паттерн является настолько общим, что в Rust есть встроенная в язык конструкция для него, она называется циклом `while`. Листинг 3-3 использует `while`: программа выполняет цикл три раза, каждый раз уменьшая счетчик и печатая, а затем после цикла она печатает другое сообщение и завершается.

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```

<span class="caption">Листинг 3-3: Использует цикл <code>while</code> для выполнения кода, пока условие истинно</span>

Данная конструкция устраняет множество вложенностей , которые понадобились бы при использовании `loop`, `if`, `else` и `break` и является более понятной. Пока условие является истинным, код выполняется; иначе происходит выход из цикла.

#### Цикл по коллекции с помощью `for`

Можно использовать конструкцию `while` для прохода по элементам коллекции, таким как массив. Например, посмотрим на листинг 3-4.

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
```

<span class="caption">Листинг 3-4: Проход по элементам коллекции используя цикл <code>while</code></span>

Данный код проходит по всем элементам массива. Он начинается с индекса `0` и затем идет далее, пока не достигнет последнего индекса массива (когда условие `index < 5` больше не является истинным). Запуск данного кода печатает каждый элемента массива:

```text
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
```

Все пять значений печатаются в терминале как и ожидалось. Даже если `index` в некоторый момент достигнет значения `5` , то цикл прекратит выполнение до того, как мы попытаемся извлечь шестой, не существующий элемент из массива.

Данный подход избавлен от ошибок, которые могут привести к панике программы в случае не корректного значения величины индекса. Он также является медленным, потому что компилятор добавляет дополнительный код условных проверок на каждом элементе каждой итерации цикла.

Как более краткая альтернатива, можно использовать цикл `for` и выполнять некоторый код для каждого элемента в коллекции. Цикл `for` выглядит как на листинге 3-5.

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
```

<span class="caption">Листинг 3-5: Проход по всем элементам коллекции используя цикл <code>for</code></span>

При запуске данного кода, мы увидим вывод подобный листингу 3-4. Более важно то, что мы увеличили безопастность кода и уменьшили шанс появления ошибки, которая могла бы получится из-за выхода за границы массива или прохода не до конца и пропуска некоторых элементов.

Например, если удалить элемент из массива `a` в коде листинга 3-4, но забыть обновить условие `while index < 4`, то код завершиться паникой. Используя цикл `for` вам не придется помнить, что необходимо изменение любого другого кода, при изменении количества элементов в массиве.

Безопасность и краткость цикла `for` делает его наиболее используемой конструкцией циклов в Rust. Даже в ситуации в которой вы хотите запустить некоторый код определенное количество раз, как в примере обратного счета где используется цикл `while` в листинге 3-3, большая часть разработчиков Rust использовала бы цикл `for`. Способом сделать это, было бы использование типа `Range`, который является типом предоставляемым стандартной библиотекой, которая генерирует все числа последовательности начиная от первого числа указанного диапазона и заканивая последним числом, которое само не включается в диапазон.

Вот так может выглядеть обратный отсчет используя цикл `for` и другой метод, который мы еще не рассматривали,  `rev` для реверса диапазона:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
```

Данный код выглядит лучше, не так ли?

## Итоги

Это была обширная глава. Вы познакомились с переменными, скалярными и сложными типами данных, функциями, комментариями,  выражениями `if`  и циклами. Если хотите практиковаться с концепциями рассмотренными в данной главе, то попробуйте написать следующие программы:

- Конвертер температур из единиц Фаренгейта в единицы Цельсия.
- Генератор чисел Фибоначчи.
- Генератор строк сказки "12 дней Рождества".

Если вы готовы двигаться далее, то в следующей главе мы расскажем о концепции языка  Rust, которая *отсутствует* в других языках - это владение.
