## Создание однопоточного веб-сервера

Начнём с получения рабочего однопоточного веб-сервера. Прежде чем мы начнём, давайте посмотрим на краткий обзор протоколов, участвующих в создании веб серверов. Детали этих протоколов выходят за рамки этой книги, но краткий обзор предоставит вам необходимую информацию.

Двумя основными протоколами, используемыми в веб-серверах, являются *протокол передачи гипертекста* *(HTTP - Hypertext Transfer Protocol)* и *Протокол управления передачей* *(TCP - Transmission Control Protocol)*. Оба протокола являются протоколами типа *запрос-ответ* (request-response), то есть *клиент* инициирует запросы, а *сервер* слушает запросы и предоставляет ответ клиенту. Содержимое этих запросов и ответов определяется протоколами.

TCP - это протокол нижнего уровня, который описывает детали того, как информация попадает от одного сервера другому, но не указывает, что это за информация. HTTP строится поверх TCP, определяя содержимое запросов и ответов. Технически возможно использовать HTTP с другими протоколами, но в в подавляющем большинстве случаев HTTP отправляет свои данные по TCP. Мы будем работать с сырыми байтами TCP и HTTP запросов и ответов.

### Прослушивание TCP соединения

Наш веб-сервер должен прослушивать TCP-соединение, так что это будет первой частью над которой мы будем работать. Стандартная библиотека предлагает модуль `std::net` который позволяет нам это делать. Давайте сделаем новый проект обычным способом:

```text
$ cargo new hello --bin
     Created binary (application) `hello` project
$ cd hello
```

Теперь введите код листинга 20-1 в файл *src/main.rs* для начала. Этот код будет прослушивать входящие TCP потоки по адресу `127.0.0.1:7878`. Когда сервер принимает входящий поток, он напечатает `Connection established!`.

<span class="filename">Файл: src/main.rs</span>

```rust,no_run
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:8080").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("Connection established!");
    }
}
```

<span class="caption">Листинг 20-1: Приём и прослушивание входящих потоков, печать сообщения, когда мы получаем поток</span>

Используя `TcpListener`, можно прослушивать TCP соединения по адресу `127.0.0.1:7878`. В адресе, в его части перед двоеточием, сначала идёт IP-адрес представляя ваш компьютер (он одинаковый на каждом компьютере и не представляет конкретный компьютер автора), а часть `7878` является портом. Мы выбрали этот порт по двум причинам: HTTP обычно может принимает на этом порту, и 7878 - это слово *rust* набранное на телефоне.

Функция `bind` в этом сценарии работает как функция `new`, в том плане что она вернёт новый экземпляр `TcpListener`. Причина по которой функция называется `bind` заключается в том, что в сети подключение к порту для прослушивания известно как "привязка к порту", которую можно сделать только один раз из одной программы в системе, до тех пор пока порт не освобождён программой.

Функция `bind` возвращает `Result<T, E>`, который указывает, что привязка может потерпеть неудачу. Например, для подключения к порту 80 требуется привилегии администратора (не администраторы могут прослушивать только на портах выше 1024), поэтому, если бы мы попытались подключиться к порту 80 не имея привилегии администратора, то привязка не сработает. В качестве другого примера привязка может не работать, если мы запустим два экземпляра нашей программы, так чтобы две программы прослушивали бы один и тот же порт. Так как мы пишем базовый сервер только для учебных целей, мы не будем беспокоиться об обработке ошибок такого рода; вместо этого мы используем `unwrap`, чтобы остановить программу, если ошибка произойдёт.

Метод `incoming` в`TcpListener` возвращает итератор, который предоставляет последовательность потоков (более конкретно, потоки типа `TcpStream`). Единичный *поток* (stream) представляет собой открытое соединение между клиентом и сервером. *Соединение* (connection) - это название для полного процесса запроса и ответа в котором клиент подключается к серверу, сервер генерирует ответ и сервер закрывает соединение от клиента. Таким образом, `TcpStream` будет читать данные из себя, чтобы видеть, что клиент нам отправил и затем позволит писать наш ответ в этот поток. В целом, этот цикл `for` будет обрабатывать каждое соединение по очереди и производить серию потоков нам для обработки запросов.

На данный момент обработка потока состоит из вызова `unwrap` для завершения программы, если поток имеет какие-либо ошибки, а если ошибок нет, то печатается сообщение. Мы добавим больше функциональности для случая успешной работы в следующем листинге кода. Причина, по которой мы можем получить ошибки из метода `incoming` при подключении клиента к серверу, является то, что мы на самом деле не перебираем соединения. Вместо этого мы перебираем *попытки подключения*. Соединение может быть не успешным по ряду причин, многие из них специфичны в операционной системе. Например, многие операционные системы имеют ограничение количества одновременных открытых соединений, которые они поддерживают; попытки создания нового соединения, превышающее это число, будут приводить к ошибкам до тех пор, пока некоторые из ранее открытых соединений не будут закрыты.

Давайте попробуем запустить этот код! Вызовем команду `cargo run` в терминале и затем откроем строку *127.0.0.1:7878* в веб-браузере. Браузер должен показать сообщение об ошибке типа "Соединение сброшено" (Connection reset), потому что сервер в данный момент не отправляет никаких данных ответа браузеру. Но когда вы смотрите на свой терминал, вы должны увидеть несколько сообщений, которые были напечатаны, когда браузер подключился к серверу!

```text
     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
```

Иногда вы увидите несколько сообщений, напечатанных для одного запроса браузера; Причиной может быть то, что браузер делает запрос страницы, а также сам запрашивает другие ресурсы, например значок *favicon.ico*, который отображается на вкладке браузера.

Может случиться так, что браузер пытается подключиться к серверу несколько раз, потому что сервер не отправляет в ответ никаких данных. Когда экземпляр `stream` выходит из области видимости и он удаляется в конце цикла, соединение закрывается как часть реализации типажа `drop`. Браузеры иногда обрабатывают закрытое соединение с помощью повторных запросов, потому что это может быть временной проблемой. Важным фактором является то, что успешно удалось обработать TCP соединение!

Не забудьте остановить программу, нажав клавишную комбинацию <span class="keystroke">ctrl-c</span>, после того как закончите запуск очередной версии кода. Затем перезапустите `cargo run` после внесения каждого набора изменений кода, чтобы убедиться, что вы используете обновлённый код.

### Чтение запросов

Давайте реализуем функционал чтения запроса из браузера! Чтобы разделить проблемы начального получения соединение, а затем выполнения некоторого действия на соединении, мы запустим новую функцию для обработки соединений. В этой новой функции `handle_connection` будем читать данные из потока TCP и распечатывать его, чтобы видеть данные, отправляемые из браузера. Измените код как в листинге 20-2.

<span class="filename">Файл: src/main.rs</span>

```rust,no_run
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:8080").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&mut buffer).unwrap();

    println!("Request: {}", String::from_utf8_lossy(&buffer[..]));
}
```

<span class="caption">Листинг 20-2: Чтение из потока <code>TcpStream</code> и печать данных</span>

Мы добавили `std::io::prelude` в область видимости, чтобы получить доступ к типажам, которые позволяют читать и писать в поток. В цикле `for` функции `main` вместо того, чтобы печатать сообщение о том, что мы установили соединение, мы теперь вызываем новую функцию `handle_connection` и передаём ей `stream`.

В функции `handle_connection` мы сделали параметр `stream` изменяемым. Причина в том, что экземпляр `TcpStream` внутри отслеживает, какие данные он нам возвращает. Он может прочитать больше данных, чем мы просили и сохранить эти данные для следующего раза, когда мы просим данные. Поэтому он должен быть `mut` так как его внутреннее состояние может измениться; обычно мы думаем о "чтении" как об операции не нуждающейся в изменении данных, но в данном случае нам нужно ключевое слово `mut`.

Далее нам нужно читать из потока. Мы делаем это в два этапа: сначала объявляем переменную `buffer` для хранения считываемых данных в стеке. Мы сделали буфер размером 512 байт, что достаточно для хранения данных основного запроса и достаточно для наших целей этой главы. Если бы мы хотели обрабатывать запросы произвольного размера, управление буфером было бы более сложным; пока мы все упрощаем. Мы передаём буфер в `stream.read`, который прочитает байты из `TcpStream` и поместит их в буфер.

Во-вторых, мы конвертируем байты буфера в строку и печатаем эту строку. Функция `String::from_utf8_lossy` принимает `&[u8]` и создаёт из неё `String`. Названия «lossy» (с потерями) в её имени указывает на поведение этой функции. Когда она видит недопустимую последовательность UTF-8: она заменяет недопустимую последовательность на символ `�`, символ замены `U+FFFD REPLACEMENT CHARACTER`. Вы могли видеть заменяющие символы в буфере, который не заполнен данными из запроса.

Давайте попробуем этот код! Запустите программу и снова сделайте запрос в веб-браузере. Обратите внимание, что мы все равно получим страницу с ошибкой в браузере, но наш вывод программы в терминале теперь будет выглядеть примерно так:

```text
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42 secs
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:8080
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
������������������������������������
```

В зависимости от вашего браузера, вы можете получить немного другие результаты. Теперь, когда мы печатаем данные запроса, мы можем понять, почему мы получаем несколько соединений от одного запроса браузера посмотрев на путь после `Request: GET`. Если повторные соединения запрашивают путь */*, мы знаем, что браузер пытается запросить */* повторно, потому что он не получает ответ от нашей программы.

Давайте разберём эти данные из запроса, чтобы понять, что запрашивает браузер у нашей программы.

### Пристальный взгляд на HTTP запрос

HTTP - это текстовый протокол и запрос имеет следующий формат:

```text
Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
```

Первая строка - это *строка запроса* (request line), которая содержит информацию о том, что запрашивает клиент. Первая часть строки запроса указывает используемый *метод*, например, `GET` или `POST`, который описывает, как клиент делает этот запрос. Наш клиент использовал запрос `GET`.

Следующая часть строки запроса - это символ */*, который указывает на *унифицированный идентификатор ресурса* *(URI - Uniform Resource Identifier)*, который запрашивается клиентом: URI является почти, но не совсем тем же что и *универсальный указатель ресурса* *(URL - Uniform Resource Locator)*. Разница между URI и URL адресами не важна для целей в этой главе, но спецификация HTTP использует термин URI, поэтому мы можем просто мысленно заменить URL на URI.

Последняя часть - это версия HTTP, которую использует клиент, а затем строка запроса заканчивается *CRLF последовательностью*. (CRLF означает *возврат каретки* (CR - carriage return) и *перевод строки* (LF - line feed), являющиеся терминами с дней пишущих машинок!) Последовательность CRLF также может записывается как `\r\n`, где `\r` - возврат каретки, а `\n` - перевод строки. Последовательность CRLF отделяет строку запроса от остальной части данных запроса. Обратите внимание, что при печати CRLF мы видим как начало новой строки, а не как `\r\n`.

Глядя на данные строки запроса, которые мы получили при запуске программы, мы видим что `GET` - это метод, */* - это URI запроса, а `HTTP/1.1` - это версия протокола.

Строки, оставшиеся после строки с запросом, начиная с заголовка `Host:` и далее, являются заголовками. `GET` запросы не имеют тела запроса.

Попробуйте сделать запрос из другого браузера или запросить другой адрес, такой как *127.0.0.1:7878/test*, чтобы увидеть как изменяются данные запроса.

Теперь, когда мы знаем, что запрашивает браузер, давайте отправим обратно в ответ некоторые данные!

### Написание ответа

Теперь мы реализуем отправку данных в ответ на запрос клиента. Ответы имеют следующий формат:

```text
HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
```

Первая строка является *строкой состояния*, содержащая версию HTTP используемого для ответа, числовой код состояния, который суммирует результат запроса и фразу причины, которая представляет текстовое описание кода состояния. После последовательности CRLF находятся любые заголовки, другая последовательность CRLF и тело ответа.

Вот пример ответа, который использует HTTP версии 1.1, имеет код состояния равный 200, фразу успешного ответа OK, без заголовков и без тела:

```text
HTTP/1.1 200 OK\r\n\r\n
```

Код состояния 200 является стандартным ответом об успехе. Данный текст это короткий успешный HTTP ответ. Давайте запишем его в поток как ответ на успешный запрос! Из функции `handle_connection` удалите `println!`, который печатал данные запроса и замените его кодом в листинге 20-3.

<span class="filename">Файл: src/main.rs</span>

```rust
# use std::io::prelude::*;
# use std::net::TcpStream;
fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&mut buffer).unwrap();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```

<span class="caption">Листинг 20-3: Запись короткого успешного HTTP ответа в поток</span>

Первая новая строка определяет переменную `response`, которая содержит данные для  успешного сообщения. Затем мы вызываем `as_bytes` у переменной `response`, чтобы преобразовать строку в  байт данные. Метод `write` у `stream` принимает `&[u8]` и отправляет эти байты напрямую в соединение.

Поскольку операция `write` могла завершиться неудачно, мы как и ранее используем `unwrap` для любого результата с ошибкой. Опять же, в реальном приложении вы здесь добавили бы обработку ошибок. Наконец, вызов `flush` будет ждать и не позволит программе продолжить выполнение, пока все байты ответа записываются в соединение; `TcpStream` содержит внутренний буфер для минимизации вызовов базовой операционной системы.

Сделав этим изменения давайте запустим код и сделаем запрос. Мы больше не выводим в терминал любые данные, поэтому мы не увидим ничего, кроме вывода из Cargo. Когда вы загружаете адрес *127.0.0.1:7878* в веб-браузер, вы должны получить пустую страницу вместо ошибки. Вы только что вручную закодировали запрос и ответ HTTP!

### Возвращение реального HTML

Давайте реализуем функциональность для возврата больше чем пустой страницы. Создайте новый файл *hello.html*, находящийся в корневом каталоге вашего проекта, а не в каталоге *src*. Вы можете поместить любой HTML код, который вы хотите; Листинг 20-4 показывает возможный вариант.

<span class="filename">Файл: hello.html</span>

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hello!</title>
  </head>
  <body>
    <h1>Hello!</h1>
    <p>Hi from Rust</p>
  </body>
</html>
```

<span class="caption">Листинг 20-4: Пример HTML файла для возврата в ответ</span>

Это минимальный HTML5 документ с заголовком и текстом. Чтобы вернуть его из сервера при получении запроса клиента, мы поменяем функцию `handle_connection` как показано в листинге 20-5 для чтения HTML файла, добавлению его в тело ответа и его отправки.

<span class="filename">Файл: src/main.rs</span>

```rust
# use std::io::prelude::*;
# use std::net::TcpStream;
use std::fs;
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&mut buffer).unwrap();

    let contents = fs::read_to_string("hello.html").unwrap();

    let response = format!("HTTP/1.1 200 OK\r\n\r\n{}", contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```

<span class="caption">Листинг 20-5: Отправка содержимого <em>hello.html</em> как тело ответа</span>

Мы добавили строчку вверху, чтобы подключить модуль файловой системы из стандартной библиотеки в область видимости. Код для чтения содержимого файла в строковую переменную должен быть знаком; мы использовали его в главе 12, когда читали содержимое файла для нашего проекта ввода-вывода в листинге 12-4.

Далее мы используем макрос `format!`, чтобы добавить содержимое файла как тело успешного ответ.

Запустите этот код командой `cargo run` и загрузите *127.0.0.1:7878* в браузере; вы должны увидеть выведенный HTML в браузере!

В настоящее время мы игнорируем данные запроса в `buffer` и просто отправляем в ответ содержимое файла HTML. Это означает, что если вы попытаетесь запросить *127.0.0.1:7878/something-else* в браузере, вы все равно получите тот же HTML ответ. Наш сервер реализован очень ограниченным и это не то, что делают большинство веб-серверов. Мы хотим настроить наши ответы в зависимости от запроса и отправлять в ответ HTML файл для правильно сформированного запроса для пути */*.

### Проверка запроса и выборочное возвращение ответа

Прямо сейчас наш веб-сервер вернёт HTML из файла независимо от того, что запросил клиент. Давайте добавим функциональность, чтобы проверить, что браузер запрашивает */* перед возвратом HTML файла и вернём ошибку, если браузер запрашивает что-нибудь другое. Для этого нам нужно изменить `handle_connection` как показано в листинге 20-6. Этот новый код проверяет содержание запроса сравнивая его с  запросом ресурса */* и добавим блоки `if` и `else` для разной обработки запросов.

<span class="filename">Файл: src/main.rs</span>

```rust
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs;
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&mut buffer).unwrap();

    let get = b"GET / HTTP/1.1\r\n";

    if buffer.starts_with(get) {
        let contents = fs::read_to_string("hello.html").unwrap();

        let response = format!("HTTP/1.1 200 OK\r\n\r\n{}", contents);

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else {
        // some other request
    }
}
```

<span class="caption">Листинг 20-6: Сопоставление запроса и обработка запросов для корневого ресурса <em>/</em>, отличающимся от запросов других ресурсов</span>

Сначала мы жёстко закодируем данные, соответствующие коревому запросу */* в переменной `get`. Поскольку мы читаем сырые байты в буфер, мы конвертирует `get` в строку байт, добавляя в начале содержимого строки символ `b""` байт синтаксиса. Затем мы проверяем, начинается ли `buffer` с байтов как в переменной `get`. Если это так, то это означает, что мы получили правильно сформированный запрос ресурса */*, что является успешным случаем обработанным в блоке `if`, который возвращает содержимое HTML файла.

Если `buffer` *не начинается* байтами из переменной `get`, то это означает, что мы получили какой-то другой запрос. Мы скоро добавим код в блок `else`, чтобы ответить на все остальные запросы.

Запустите этот код и запросите адрес *127.0.0.1:7878* в браузере. Вы должны получить HTML из файла *hello.html*. Если вы сделаете любой другой запрос, такой как *127.0.0.1:7878/something-else*, то получите ошибку соединения, подобную той что вы видели при запуске кода в листинге 20-1 и листинге 20-2.

Теперь давайте добавим код листинга 20-7 внутрь блока `else`, чтобы вернуть ответ с кодом состояния 404, который сигнализирует о том, что контент запроса не был найден. Мы также вернём HTML для страницы, отображаемой в браузере с указанием ответа конечному пользователю.

<span class="filename">Файл: src/main.rs</span>

```rust
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs;
# fn handle_connection(mut stream: TcpStream) {
# if true {
// --snip--

} else {
    let status_line = "HTTP/1.1 404 NOT FOUND\r\n\r\n";
    let contents = fs::read_to_string("404.html").unwrap();

    let response = format!("{}{}", status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
# }
```

<span class="caption">Листинг 20-7: Отвечаем кодом состояния 404 и страницей ошибки, если было запрошено что-то отличающееся от ресурса <em>/</em></span>

Здесь ответ имеет строку состояния с кодом 404 и фразу причины `NOT FOUND`. Мы по-прежнему не возвращаем заголовки, а тело ответа будет HTML из файла *404.html*. Вам нужно создать файл *404.html* рядом с *hello.html* для этой страницы ошибки; снова не стесняйтесь использовать любой HTML код или пример HTML кода листинга 20-8.

<span class="filename">Файл: 404.html</span>

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hello!</title>
  </head>
  <body>
    <h1>Oops!</h1>
    <p>Sorry, I don't know what you're asking for.</p>
  </body>
</html>
```

<span class="caption">Листинг 20-8: Пример содержимого страницы для отправки с любым ответом 404</span>

Запустите сервер снова вместе со внесёнными изменениями. Запрашивая *127.0.0.1:7878* сервер должен вернуть содержимое файла *hello.html*, а любой другой запрос вроде *127.0.0.1:7878/foo*, должен вернуть HTML страницу ошибки *404.html*.

### Рефакторинг

На данный момент блоки `if` и `else` имеют много повторяющегося кода: они оба читают файлы и записывают содержимое файла в поток. Единственными отличиями являются строка состояния и имя файла. Давайте сделаем код более кратким, выделив эти различия в отдельные строки `if` и `else` которые будут присваивать значения строки состояния и имени файла переменным; затем мы можем просто использовать эти переменные в коде для чтения файла и записи ответа. Листинг 20-9 показывает полученный код после переделки больших блоков `if` и `else`.

<span class="filename">Файл: src/main.rs</span>

```rust
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs;
// --snip--

fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 512];
#     stream.read(&mut buffer).unwrap();
#
#     let get = b"GET / HTTP/1.1\r\n";
    // --snip--

    let (status_line, filename) = if buffer.starts_with(get) {
        ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!("{}{}", status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```

<span class="caption">Листинг 20-9: Рефакторинг блоков <code>if</code> и <code>else</code>, содержащих только код различающийся в обоих случаях</span>

Теперь блоки `if` и `else` возвращают только соответствующие значения для строки состояния и имени файла в кортеже; Затем мы используем деструктуризацию для назначения кортежа значениям двух переменных `status_line` и `filename` с использованием шаблона в выражении `let`, что обсуждалось в главе 18.

Ранее дублированный код теперь находится вне блоков `if` и `else` и использует переменные `status_line` и `filename`. Это позволяет легче увидеть разницу между этими двумя случаями и означает, что у нас есть только одно место для обновления кода, если захотим изменить работу чтения файлов и записи ответов. Поведение кода в листинге 20-9 будет таким же, как и в листинге 20-8.

Потрясающие! Теперь у нас есть простой веб-сервер из примерно 40 строк кода Rust, который отвечает на один запрос страницей контента и отвечает на все другие запросы ответом с ошибкой 404.

В данное время сервер работает в одном потоке, то есть он может обслуживать только один запрос за один раз. Давайте рассмотрим, как почему это может стать проблемой с помощью моделирования медленных запросов. Затем мы исправим эту проблему, чтобы наш сервер мог обрабатывать несколько запросов одновременно.
