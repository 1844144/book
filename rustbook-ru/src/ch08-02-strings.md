## Сохранение текста с UTF-8 кодировкой в строках

Мы говорили о строках в главе 4, но сейчас мы рассмотрим их более подробно. Новички в Rust обычно застревают на строках из-за  комбинации трех причин: склонность Rust компилятора к выявлению возможных ошибок, более сложная структура данных чем считают многие программисты и UTF-8. Эти факторы объединяются таким образом, что тема может показаться сложной, если вы пришли из других языков программирования.

Полезно обсуждать строки в контексте коллекций, потому что строки реализованы в виде набора байтов, плюс некоторые методы для обеспечения полезной функциональности, когда эти байты интерпретируются как текст. В этом разделе мы поговорим об операциях над `String` , которые есть у каждого типа коллекций такие как создание, обновление и чтение. Мы также обсудим способы, которыми `String` отличается от других коллекций, а именно, как индексирование в `String` осложняется различием между тем, как люди и компьютеры интерпретируют `String` данные.

### Что же такое строка?

Сначала мы определим, что мы подразумеваем под термином *строка* . В Rust есть только один строковый тип в ядре языка, который является срезом строки `str` , обычно используемой в заимствованном виде как `&str` . В главе 4 мы говорили о *срезах строк* которые являются ссылками на некоторые строковые данные в кодировке UTF-8. Например,  строковые литералы хранятся в двоичном файле программы и поэтому являются срезами строк.

Тип `String` предоставляемый стандартной библиотекой Rust, не встроен в ядро языка и является расширяемым, изменяемым, владеющим, строковым типом в UTF-8 кодировке. Когда Rust разработчики говорят о «строках» то, они обычно имеют ввиду типы `String` и строковые срезы `&str` , а не просто один из них. Хотя этот раздел в основном посвящен `String` , оба типа интенсивно используются в стандартной библиотеке Rust, и `String` и строковые срезы кодируются в UTF-8.

Стандартная библиотека Rust также включает ряд других строковых типов, таких как `OsString` , `OsStr` , `CString` и `CStr` . Библиотечные крейты могут предоставить даже большее количество возможностей для хранения строковых данных. Посмотрите, как все эти имена заканчиваются на `String` или `Str` ? Они относятся к собственным и заимствованным вариантам, так же как `String` и тип `str` которые вы видели ранее. Эти типы строк могут хранить текст в различных кодировках или например, быть по-другому представлены в памяти. Мы не будем обсуждать эти другие типы строк в данной главе; посмотрите документацию API для получения дополнительной информации о том как их использовать и когда каждый тип уместен.

### Создание новых строк

Многие из операций доступных в `Vec<T>`, доступны также в `String` , начиная с функции `new` для создания строки, показанной в листинге 8-11.

```rust
let mut s = String::new();
```

<span class="caption">Листинг 8-11. Создание новой пустой <code>String</code></span>

Эта строка создает новую пустую строковую переменную с именем `s` , в которую мы можем затем загрузить данные. Часто у нас есть некоторые начальные данные, которые мы хотим назначить строке. Для этого используется метод `to_string` , который доступен для любого типа, который реализует типаж `Display` присутствующий у строковых литералов. Листинг 8-12 показывает два примера.

```rust
let data = "initial contents";

let s = data.to_string();

// метод работает также прямо на литералах:
let s = "initial contents".to_string();
```

<span class="caption">Листинг 8-12. Использование метода <code>to_string</code> для создания экземпляра типа <code>String</code> из строкового литерала</span>

Эти выражения создают строку с  `initial contents`.

Мы также можем использовать функцию `String::from` для создания `String` из строкового литерала. Код листинга 8-13 является эквивалентным коду из листинга 8-12, который использует функцию `to_string`:

```rust
let s = String::from("initial contents");
```

<span class="caption">Листинг 8-13. Использование функции <code>String::from</code> для создания <code>String</code> из строкового литерала</span>

Поскольку строки используются для очень многих вещей, можно использовать множество API для строк, предоставляющих множество возможностей. Некоторые из них могут показаться избыточными, но все они занимаются своим делом! В данном случае `String::from` и `to_string` делают одно и тоже, поэтому выбор зависит от стиля.

Запомните, что строки хранятся в кодировке UTF-8, поэтому можно использовать любые правильно кодированные данные в них, как показано в листинге 8-14:

```rust
let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hello");
let hello = String::from("שָׁלוֹם");
let hello = String::from("नमस्ते");
let hello = String::from("こんにちは");
let hello = String::from("안녕하세요");
let hello = String::from("你好");
let hello = String::from("Olá");
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
```

<span class="caption">Листинг 8-14. Хранение приветствий в строках на разных языках</span>

Все это допустимые `String` значения.

### Обновление строковых данных

`String` может увеличиваться в размере, а ее содержимое может меняться при вставке в нее большего количества данных, как и содержимое `Vec<T>`. Кроме того, можно использовать оператор `+` или макрос `format!` для объединения значений `String`.

#### Присоединение к строке с помощью `push_str` и `push`

Можно увеличить `String` для добавления фрагмента строки, используя метод `push_str` как показано в листинге 8-15.

```rust
let mut s = String::from("foo");
s.push_str("bar");
```

<span class="caption">Листинг 8-15: Добавление среза строки к <code>String</code> используя метод <code>push_str</code></span>

После этих двух строк `s` будет содержать `foobar` . Метод `push_str` принимает строковый срез, потому что мы не всегда хотим владеть параметром. Например, код в листинге 8-16 показывает, что будет нежелательным, если мы не сможем использовать `s2` после добавления его содержимого к содержимому переменной `s1` .

```rust
let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2);
println!("s2 is {}", s2);
```

<span class="caption">Листинг 8-16. Использование среза строки после добавления его
содержимого к <code>String</code></span>

Если метод `push_str` стал бы владельцем переменной `s2` , мы не смогли бы напечатать его значение в последней строке. Однако этот код работает так, как мы ожидали!

Метод `push` принимает один символ в качестве параметра и добавляет его к `String` В листинге 8-17 показан код, добавляющий букву {em2}l{/em2} к {code3}String{/code3} , используя метод {code4}push{/code4} .

```rust
let mut s = String::from("lo");
s.push('l');
```

<span class="caption">Листинг 8-17. Добавление одного символа к значению  <code>String</code> , используя <code>push</code></span>

После этого переменная `s` будет содержать `lol`.

#### Объединение с помощью оператора + или макроса `format!`

Часто хочется объединять две существующие строки. Один из возможных способов это использование оператора `+` из листинга 8-18:

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // заметьте здесь s1 было перемещено и не может больше использоваться
```

<span class="caption">Листинг 8-18. Использование оператора <code>+</code> для объединения двух значений <code>String</code> в новое <code>String</code> значение</span>

Строка `s3` будет содержать `Hello, world!` как результат выполнения этого кода. Причина того, что `s1` после добавления больше не действительна и причина, по которой мы использовали ссылку на `s2` имеют отношение к сигнатуре вызываемого метода при использовании оператора `+` . Оператор `+` использует метод `add` , чья сигнатура выглядит примерно так:

```rust,ignore
fn add(self, s: &str) -> String {
```

Это не точная сигнатура из стандартной библиотеки: в стандартной библиотеке `add` определен с помощью обобщенных типов. Здесь мы видим сигнатуру `add` с конкретными типами, заменяющими обобщенный, что происходит когда вызывается данный метод со значениями `String` . Обсудим обобщенные типы в главе 10. Эта сигнатура дает нам ключ для понимания хитрых особенности оператора `+` .

Во-первых, `s2` имеет `&` , означающее добавление *ссылки* на вторую строку к первой строки, из-за параметра `s` в функции `add` : она может добавлять только `&str` к `String` ; мы не можем скомбинировать два значения `String` вместе. Но подождите - тип `&s2` - это `&String` , а не `&str` , как указано во втором параметре `add` . Так почему компилируется код в листинге 8-18?

Причина, по которой мы можем использовать `&s2` в вызове `add` заключается в том, что компилятор может *принудительно привести* (coerce) аргумент типа `&String` к типу `&str` . Когда мы называем метод `add` в Rust используется *принудительное приведение* (deref coercion), которое превращает `&s2` в `&s2[..]` . Мы подробно обсудим принудительное приведение с помощью оператора deref в главе 15. Так как `add` не забирает во владение параметр `s` , `s2` прежнему будет действительным типом `String` после этой операции.

Во-вторых, как можно увидеть по сигнатуре метод `add` забирает во владение `self` , потому что `self` *не* имеет `&` . Это означает, что `s1` в листинге 8-18 будет перемещен в вызов `add` и больше не будет действительной после этого. Не смотря на то, что `let s3 = s1 + &s2;` выглядит как будто он скопирует обе строки и создает новую, это выражение фактически забирает во владение переменную `s1` , добавляет копию содержимого `s2` , а затем возвращает владение полученного результата. Другими словами, это выглядит как он создание множества копий, но это не так; данная реализация более эффективна чем копирование.

Если нужно объединить несколько строк, поведение оператора `+` становится громоздким:

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &s2 + "-" + &s3;
```

На этом этапе переменная `s` будет содержать `tic-tac-toe` . С множеством `+` и `"` символов становится трудно понять, что происходит. Для более сложного комбинирования строк можно использовать макрос `format!` :

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{}-{}-{}", s1, s2, s3);
```

Этот код также устанавливает переменную `s` в значение `tic-tac-toe` . Макрос `format!` работает тем же способом что макрос `println!` , но вместо вывода на экран возвращает тип `String` с содержимым. Версия кода с использованием `format!` значительно легче читается и не забирает во владение ни за один из его параметров.

### Индексирование в строках

Доступ к отдельным символам в строке, ссылаясь на них по индексу, является допустимой и распространенной операцией во многих других языках программирования. Тем не мение, вы получить ошибку при попытке получить доступ к частям `String` , используя синтаксический индекс в Rust. Рассмотрим неверный код в листинге 8-19.

```rust,ignore,does_not_compile
let s1 = String::from("hello");
let h = s1[0];
```

<span class="caption">Листинг 8-19. Попытка использовать синтаксический индекс со строкой</span>

Этот код приведет к следующей ошибке:

```text
error[E0277]: the trait bound `std::string::String: std::ops::Index<{integer}>` is not satisfied
 -->
  |
3 |     let h = s1[0];
  |             ^^^^^ the type `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index<{integer}>` is not implemented for `std::string::String`
```

Ошибка и примечание говорит, что в Rust строки не поддерживают индексацию. Но почему нет? Чтобы ответить на этот вопрос, нужно обсудить то, как Rust хранит строки в памяти.

#### Внутренее представление

Тип `String` является оболочкой над типом `Vec<u8>` . Давайте посмотрим на некоторые корректным образом закодированные строки UTF-8 из примера листинга 8-14. Во-первых, этот:

```rust
let len = String::from("Hola").len();
```

В этом случае `len` будет 4, что означает вектор, хранит строку «Hola» длиной 4 байта. Каждая из этих букв занимает 1 байт при кодировании в UTF-8. Но как насчет следующей строки? (Обратите внимание, что эта строка начинается с заглавной кириллической Зэ, а не арабской цифры 3.)

```rust
let len = String::from("Здравствуйте").len();
```

На вопрос какова длина строки, вы можете ответить 12. Однако ответ Rust равен 24: это число байтов, необходимое для кодирования «Здравствуйте» в UTF-8, потому что каждое скалярное значение Unicode в этой строке занимает 2 байта памяти. Следовательно, индекс в байтах строки не всегда соответствует действительному скалярному значению Unicode. Для демонстрации рассмотрим этот недопустимый в Rust код:

```rust,ignore,does_not_compile
let hello = "Здравствуйте";
let answer = &hello[0];
```

Каким должно быть значение `answer` ? Должно ли оно быть `З` , первой букве? При кодировке в UTF-8, первый байт значения `З` равен `208`, а второй - `151` , поэтому `answer` должен быть на самом деле `208` , но само по себе `208` не является действительным символом. Возвращение `208` , скорее всего не то, что хотел бы получить пользователь, если спросил первую букву этой строки; тем не менее, это единственный байт данных, которые Rust имеет в индексе 0. Пользователи обычно не хотят получить значение байта, даже если строка содержит только латинские буквы: если `&"hello"[0]` было бы допустимым кодом, который вернул значение байта, то он вернул бы `104` , а не `h` . Чтобы предотвратить возврат непредвиденного значения, вызывающего ошибки которые сразу не могут быть обнаружены, Rust не компилирует такой код и предотвращает недопонимание на ранних этапах процесса разработки.

#### Байты, скалярные значения и графемные кластеры! Боже мой!

Еще один момент, касающийся UTF-8, заключается в том, что на самом деле существует три способа рассмотрения строк с точки зрения Rust: как байты, скалярные значения и кластеры графем (самая близкая вещь к тому, что мы назвали бы *буквами* ).

Если посмотреть на слово языка хинди «नमस्ते», написанное в транскрипции Devanagari, то оно хранится как вектор значений `u8` который выглядит следующим образом:

```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]
```

Эти 18 байт являются именно тем, что компьютеры в конечном итоге хранят как данные. Если мы посмотрим на их как скалярные значения Unicode, которые являются Rust типом `char`, то байты выглядят так:

```text
['न', 'म', 'स', '्', 'त', 'े']
```

Здесь есть шесть значений типа `char` , но четвертый и шестой являются не буквами: они диакритики, которые не имеют смысла сами по себе. Наконец, если мы посмотрим на них как на кластеры графем, то получим то, что человек назвал бы четыре буквы составляющих слово на хинди:

```text
["न", "म", "स्", "ते"]
```

Rust предоставляет различные способы интерпретации необработанных строковых данных, которые компьютеры хранить так, чтобы каждая программа могла выбрать необходимую интерпретацию, независимо от того, на каком человеческом языке эти данные.

Последняя причина, по которой Rust не позволяет нам индексировать `String` для получения символов является то, что операции индексирования всегда будут занимать постоянное время (O(1)). Но невозможно гарантировать такую производительность для `String` , потому что Rust должен был пройтись по содержимому от начала до индекса, чтобы определить, сколько было действительных символов.

### Срезы строк

Индексирование строк часто является плохой идеей, потому что не ясно каким должен быть возвращаемый тип такой операции: байтовым значением, символом, кластером графем или срезом строки. Поэтому Rust просит быть более конкретным, если действительно нужно использовать индексы для создания срезов строк. Для большей конкретики в случае индексации нужно указать, что вы хотите срез, вместо индексирования с помощью числового индекса, и использовать оператор диапазона `[]` при создании среза строки, содержащего определенные байты:

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```

Здесь переменная `s` будет типа `&str` который содержит первые 4 байта строки. Ранее мы упоминали, что каждый из этих символов был по 2 байта, что означает `s` будет содержать `Зд` .

Что бы произошло, если бы мы использовали `&hello[0..1]` ? Ответ: Rust бы запаниковал во время выполнения таким же образом, как если бы в векторе обращались к недействительному индексу :

```text
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2188:4
```

Нужно  с осторожностью использовать диапазоны для создания срезов строк, потому что это может привести к сбою программы.

### Методы для перебора строк

Сейчас поговорим о предпочтительных способах доступа к элементам строки.

Если необходимо производить операции над отдельными элементами юникод-строки, то наилучший способ - это использовать метод `chars`. Вызов `chars` из “नमस्ते” разделяет и возвращает 6 значений типа `char`. Далее, вы можете перебирать результат для доступа к каждому элементу:

```rust
for c in "नमस्ते".chars() {
    println!("{}", c);
}
```

Код напечатает следующее:

```text
न
म
स
्
त
े
```

Метод `bytes` возвращает каждый байт, который может быть подходящим в другой предметной области:

```rust
for b in "नमस्ते".bytes() {
    println!("{}", b);
}
```

Этот код напечатает 18 байтов, составляющих эту `String` :

```text
224
164
// --snip--
165
135
```

Но не забывайте, что корректные скалярные Unicode значения могут состоять из более чем 1 байта.

Извлечение графемных кластеров из строк сложно, поэтому данный функционал не предоставляется в стандартной библиотеке. На [crates.io](https://crates.io/) доступны библиотеки, если Вам нужен данный функционал.

### Строки не так просты

Подводя итог, строки являются сложными. Различные языки программирования дают различные варианты того, как представить эту сложность для программиста. В Rust решили сделать правильную обработку данных `String` поведением по умолчанию для всех программ Rust, что означает, что программисты должны заранее думать об обработке UTF-8 данных. Этот компромисс раскрывает большую сложность строк, чем в других языках программирования, но это предотвращает от необходимости обрабатывать ошибки, связанные с не-ASCII символами в цикле разработки позже.

Давайте переключимся на что-то немного менее сложное: хэш-карты!
