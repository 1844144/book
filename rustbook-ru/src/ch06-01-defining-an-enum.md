## Определение перечисления

Рассмотрим ситуацию, когда использование перечисления весьма желательно.

Любой IP-адрес может быть адресом версии четыре или версии шесть, но не оба одновременно. Это свойство IP-адресов делает перечисление подходящей структурой данных, потому что значения перечислений могут быть только одним из его вариантов. Адреса версии четыре, так и версии шесть по-прежнему являются IP-адресами, поэтому они должны рассматриваться как один и тот же тип, когда код обрабатывает ситуации применимые к любому виду IP-адреса.

Мы можем создать определение перечисления  `IpAddrKind`:

```rust
enum IpAddrKind {
    V4,
    V6,
}
```

`IpAddrKind` is now a custom data type that we can use elsewhere in our code.

### Значения перечислений

Экземпляры каждого варианта перечисления `IpAddrKind` можно создать следующим образом:

```rust
enum IpAddrKind {
    V4,
    V6,
}
fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
}
```

Обратите внимание, что перед значением стоит идентификатор. `::` разделяет эти данные.
Две эти величины одного типа `IpAddrKind`. Следовательно, мы можем использовать этот
тип при указании типа данных функции:

```rust
 enum IpAddrKind {
     V4,
     V6,
 }

fn route(ip_type: IpAddrKind) { }
```

Можно вызвать эту функцию с любым из вариантов:

```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
# fn route(ip_kind: IpAddrKind) { }
#
route(IpAddrKind::V4);
route(IpAddrKind::V6);
```

Использование перечислений имеет даже больше преимуществ. Размышляя о нашем типе IP-адреса в данный момент, у нас нет способа сохранить фактические *данные* IP-адреса; мы
только знаем, каким он является *вариантом*. Учитывая то, что вы недавно узнали о структурах в главе 5, можно решить эту проблему как показано в листинге 6-1.

```rust
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
```

<span class="caption">Листинг 6-1: Сохранение данных  и вариантов <code>IpAddrKind</code> IP адреса используя структуру <code>struct</code></span>

Here, we’ve defined a struct `IpAddr` that has two fields: a `kind` field that
is of type `IpAddrKind` (the enum we defined previously) and an `address` field
of type `String`. We have two instances of this struct. The first, `home`, has
the value `IpAddrKind::V4` as its `kind` with associated address data of
`127.0.0.1`. The second instance, `loopback`, has the other variant of
`IpAddrKind` as its `kind` value, `V6`, and has address `::1` associated with
it. We’ve used a struct to bundle the `kind` and `address` values together, so
now the variant is associated with the value.

Мы можем представить ту же концепцию в более сжатой форме, используя только перечисление, вместо перечисления внутри структуры и помещая данные непосредственно в каждый  вариант перечисления. Это новое определение перечисления `IpAddr` говорит, что оба варианта `V4` и `V6` будут иметь связанные с ними значения типа `String` :

```rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
```

Мы добавили данные в каждый вариант перечисления. Таким образом, мы упростили наш предыдущий код и получили тот же результат.

Ещё одно преимущество использования перечисления вместо структуры заключается в том, что каждый вариант перечисления может иметь различные типы и разное количество ассоциированных данных. Версия 4 для типа IP адресов всегда будет содержать четыре цифровых компонента, которые будут иметь значения между 0 и 255. При необходимости сохранить адреса типа `V4` как четыре значения типа `u8`, а также описать адреса типа `V6` как единственное значение типа  `String`, мы не смогли бы с помощью структуры. Перечисления решают эту задачу легко:

```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
```

Мы показали несколько различных вариантов, которые можно использовать для определения
IP-адреса.

```rust
struct Ipv4Addr {
    // details elided
}

struct Ipv6Addr {
    // details elided
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

Этот код иллюстрирует возможность добавления любого типа данных в значение перечисления: строки, числа, структуры и пр. Вы даже можете включить в него другие перечисления! Стандартные типы данных не очень сложны, хотя, потенциально, могут быть очень сложными (вложенность данных может быть очень глубокой).

Обратите внимание, что хотя определение перечисления `IpAddr` есть в стандартной библиотеке, можно объявлять и использовать свою собственную реализацию без каких-либо конфликтов, потому что мы не добавили определение стандартной библиотеки в область видимости кода. Подробнее об этом поговорим в главе 7.

Рассмотрим другой пример 6-2: в этом примере каждый элемент перечисления имеете свой,
особый, тип данных внутри:

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

<span class="caption">Пример 6-2: Перечисление <code>Message</code>, в котором каждый элемент хранит различные типы и данные (наиболее удобные и нужные для использования)</span>

Это перечисление имеет 4 элемента:

- `Quit` - пустой элемент без ассоциированных данных.
- `Move` - имеющий внутри анонимную структуру.
- `Write` имеет единственную строку `String`.
- `ChangeColor` имеет кортеж из трех `i32` значений.

Определение перечисления с вариантами, такими как в листинге 6-2, похоже на определение различных видов определений структур, за исключением того, что перечисление не использует ключевое слово `struct` и все варианты сгруппированы внутри типа `Message`. Следующие структуры могут содержать те же данные, что и предыдущие варианты перечислений:

```rust
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
```

Но когда мы использовали различные структуры, которые имеют свои собственные типы, мы не могли легко определять функции, которые принимают любые типы сообщений, как можно сделать с помощью перечисления типа `Message`, объявленного в листинге 6-2, который является единым типом.

Так и структуры и перечисления - это всё группировочные типы данных, семантика
добавления функций в них идентична. Мы используем структуру `impl`:

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&self) {
        // method body would be defined here
    }
}
fn main() {
    let m = Message::Write(String::from("hello"));
    m.call();
}
```

Метод может использовать `self` для получения значения. В данном случае, `self` -
это строка..

Теперь рассмотрим наиболее часто используемое перечисление стандартной библиотеки
`Option`.

### Перечисление `Option` и его преимущества перед нулевыми значениями

В предыдущем разделе, мы рассмотрели как перечисление `IpAddr` позволяет нам использовать систему типов Rust для кодирования больше информации, чем обычные данные в программе. В данном разделе изучения перечислений, тип `Option` использован во многих мест, потому что он используется в самых распространенных сценариях, когда значение может быть чем-то или быть ничем (отсутствовать). Выражение этой концепции в терминах системы типов означает, что компилятор может проверить, обрабатываются ли все случаи, которые должны обрабатываться; эта функция позволяет предотвратить ошибки, которые очень  распространены в других языки программирования.

Дизайн языка программирования часто рассматривается с точки зрения того, какие функции вы включаете, но функции, которые вы исключаете тоже важны. Rust не имеет функциональности NULL, которая есть во многих других языках. *Null* это значение, которое означает, что нет никакой ценности. В языках с нулем переменные всегда могут быть в одном из два состояния: null или не-null.

В своей презентации 2009 года «Нулевые ссылки: ошибка в миллиард долларов», Tony Hoare, изобретатель null, сказал следующее:

> Я называю это моей ошибкой в миллиард долларов. В то время когда я проектировал первую комплексную систему типов для ссылок на объектно-ориентированном языке. Моя цель состояла в том, чтобы гарантировать, что любое использование ссылок должно быть абсолютно безопасным с проверкой, выполняющейся автоматически компилятором. Но я не мог устоять перед искушением вставить нулевую ссылку, просто потому что это было так легко для реализации. Это привело к неисчислимым ошибкам, уязвимостям и падениям систем, которые вероятно, вызвали миллиард долларов боли и ущерба за 
> последние сорок лет.

Проблема с null значениями заключается в том, что если вы попытаетесь использовать его значение в качестве ненулевого, то получите какую-то ошибку. Из-за того, что это null или не-null свойство всеобъемлющее, то очень легко сделать такую ошибку.

Тем не менее, концепция, которую null пытается выразить является полезной: null - это значение, которое в настоящее время по какой-то причине недействительное или отсутствует.

Проблема на самом деле не в концепции, а в реализация. Таким образом, у Rust нет null, но есть перечисление, которое может закодировать понятие присутствующего или отсутствующего значения. Это перечисление `Option<T>` , и оно [определяется стандартной библиотекой ](https://doc.rust-lang.org/std/option/enum.Option.html)<comment>  следующим образом:</comment>

```rust
enum Option<T> {
    Some(T),
    None,
}
```

Перечисление `Option<T>` очень важно для всей стандартной библиотеки. Также вы можете
использовать в коде элементы перечисления `Option<T>` без префикса `Option::`:`Some`,
`None`.

Синтаксис `<T>` - это особенность Rust, о которой мы еще не говорили. Это параметр обобщенного типа, и мы подробнее рассмотрим обобщенные типы в главе 10. Пока все, что вам нужно знать, это то, что `<T>` означает вариант {code2}Some{/code2} перечисления типа {code3}Option{/code3}, который может содержать фрагмент данных любого типа. Вот несколько  примеров использожания значения {code4}Option{/code4} для хранения числовых и строковых типов:

```rust
let some_number = Some(5);
let some_string = Some("a string");

let absent_number: Option<i32> = None;
```

Если мы используем значение `None`, то нам обязательно нужно указывать конкретный
тип данных, который мы будем использовать.

Если вы используете значение `Some`, то это значит, что какое-либо значение существует.
Когда вы используете значение `None`, это значит, что никакого значения нет.

Т.к. `Option<T>` и `T` (`T` - это любой тип данных) разные типы данных, компилятор
не позволяет использовать значение `Option<T>` вместо конкретного типа данных.
Этот код не будет скомпилирован, т.к. тут происходит попытка суммирования двух разных
типов данных `i8` и `Option<i8>`:

```rust,ignore,does_not_compile
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```

Запуск данного кода даст ошибку ниже:

```text
error[E0277]: the trait bound `i8: std::ops::Add<std::option::Option<i8>>` is
not satisfied
 -->
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option<i8>`
  |
```

Сильно! По сути, это сообщение об ошибке означает, что Rust не понимает, как добавить `i8` к `Option<i8>` , потому что они разного типа.  В Rust, когда мы имеет значение типа `i8`, компилятор будет гарантировать, что мы всегда имеем действительное значение. Мы можем действовать уверенно, не проверяя на null перед использованием значения. Только когда есть `Option<i8>` (или любой другой тип) мы должны беспокоиться о возможности отсутствия значения, а компилятор позаботится о том, чтобы мы рассмотрели этот случай перед использованием значение.

Для того, чтобы использовать содержащееся значение в `Some`, необходимо конвертировать
его в данные. Это также типичное действие помогающее избежать ошибок.

Если есть такая возможность, что значение может иметь нулевое значение, лучше всего
использовать тип данных `Option<T>`. Использование этого перечисления значительно
повышает уровень безопасности кода.

Вам надо хорошо разобраться с методами перечисления `Option<T>`. Это поможет вам
лучше понимать исходный код Rust стандартной библиотеки.

В следующей секции будет рассмотрена конструкция `match`. Это управляющая конструкция,
которая используется совместно с перечислениями. Результат выполнения той или иной
ветви кода зависит от значения перечисления.
