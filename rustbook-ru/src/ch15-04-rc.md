## `Rc<T>`, умный указатель с подсчетом ссылок

В большинстве случаев владение является понятным: вы точно знаете, какой переменной принадлежит данное значение. Однако существуют случаи, когда одно значение может иметь несколько владельцев. Например, в структурах граф данных несколько ребер могут указывать на один и тот же узел и этот узел концептуально принадлежит всем ребрам, указывающим на него. Узел не должен быть очищен, до тех пор пока есть ребра, указывающие на него.

Чтобы разрешить множественное владение, Rust имеет тип `Rc<T>`, который является аббревиатурой для *подсчета ссылок* (reference counting). Тип `Rc<T>` отслеживает количество ссылок на значение, где количество ссылок определяет используется ли еще значение. Если у значения остаётся ноль ссылок, это значение можно очистить и ссылки станут недействительными.

Представьте себе `Rc<T>` как телевизор в гостиной. Когда один человек входит, чтобы смотреть телевизор, он включает его. Другие могут войти в комнату и посмотреть телевизор. Когда последний человек покидает комнату, он выключает телевизор, потому что он больше не используется. Если кто-то выключит телевизор во время его просмотра другими, то оставшиеся телезрители устроят шум!

Тип `Rc<T>` используется, когда мы хотим разместить в куче некоторые данные для чтения несколькими частями нашей программы и не можем определить во время компиляции, какая из частей завершит использование данных последней. Если бы мы знали, какая часть завершит использование последней то, мы могли бы сделать эту часть владельцем данных и вступили бы в силу обычные правила владения, применяемые во время компиляции.

Обратите внимание, что `Rc<T>` используется только в одно поточных сценариях. Когда мы обсудим конкурентность в главе 16, мы рассмотрим, как выполнять подсчет ссылок во много поточных программах.

### Использование `Rc<T>` для совместного использования данных

Давайте вернемся к нашему примеру с cons списком в листинге 15-5. Напомним, что мы определили его с помощью типа `Box<T>`. В этот раз мы создадим два списка, оба из которых будут владеть третьим списком. Концептуально это похоже на рисунок 15-3:

<img alt="Two lists that share ownership of a third list" src="../../rustbook-en/src/img/trpl15-03.svg" class="center">

<span class="caption">Рисунок 15-3: Два списка <code>b</code> и <code>c</code> совместно владеют третьим списком <code>a</code></span>

Мы создадим список `a`, содержащий 5 и затем 10. Затем мы создадим еще два списка: `b` начинающийся с 3 и `c` начинающийся с 4. Оба списка `b` и `c` затем продолжать первый список `a`, содержащий 5 и 10. Другими словами, оба списка будут разделять первый список, содержащий 5 и 10.

Попытка реализовать этот сценарий, используя определение `List` с типом `Box<T>` не будет работать, как показано в листинге 15-11:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```

<span class="caption">Листинг 15-17: Демонстрация того, что нам не разрешено иметь два списка, использующих тип <code>Box<T></code>, которые пытаются разделить владение третьим списком</span>

При компиляции этого кода, мы получаем эту ошибку:

```text
error[E0382]: use of moved value: `a`
  --> src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not implement
   the `Copy` trait
```

Варианты `Cons` владеют данными, которые они содержат, поэтому, когда мы создаем список `b`, то `a` перемещается в `b`, а `b` становится владельцем `a`. Затем, мы пытаемся использовать `a` снова при создании `c`, но нам не разрешают, потому что `a` был перемещен.

Мы могли бы изменить определение типа `Cons` так, чтобы хранить ссылки, но тогда мы должны были бы указать параметры времени жизни. Указывая параметры времени жизни, пришлось бы указывать, что каждый элемент в списке будет жить как минимум столько же, сколько весь список. Анализатор заимствования, например, не позволил бы нам скомпилировать код `let a = Cons(10, &Nil);`, потому что временное значение `Nil` было бы удалено, прежде чем `a` сможет получить ссылку на него.

Вместо этого мы изменим наше определение типа `List` так, чтобы использовать `Rc<T>` вместо `Box<T>`, как показано в листинге 15-18. Каждый вариант `Cons` теперь будет содержать значение и тип `Rc<T>`, указывающий на `List`. Когда мы создадим `b` то, вместо того чтобы стал владельцем `a`, мы будем клонировать `Rc<List>` который содержит `a`, тем самым увеличивая количество ссылок с единицы до двойки и позволяя переменным `a` и `b` разделять владение на данные в типе `Rc<List>`. Мы также склонируем `a` при создании `c`, увеличивая количество ссылок с двух до трех. Каждый раз, когда мы вызываем `Rc::clone`, счетчик ссылок на данные внутри `Rc<List>` будет увеличиваться и данные не будут очищены, если на них нет нулевых ссылок.

<span class="filename">Файл: src/main.rs</span>

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```

<span class="caption">Листинг 15-18: Определение <code>List</code>, который использует тип <code>Rc<T></code></span>

Нам нужно добавить оператор `use`, чтобы подключить тип `Rc<T>` в область видимости, потому что он не входит в список автоматического импорта прелюдии. В `main`, мы создаем список владеющий 5 и 10, сохраняем его в новом `Rc<List>` переменной `a`. Затем при создании `b` и `c`, мы называем функцию `Rc::clone` и передаем ей ссылку на `Rc<List>` как аргумент `a`.

Мы могли бы вызвать `a.clone()`, а не `Rc::clone(&a)`, но в Rust принято использовать `Rc::clone` в таком случае. Внутренняя реализация `Rc::clone` не делает глубокого копирования всех данных, как это происходит в типах большинства реализаций `clone`. Вызов `Rc::clone` только увеличивает счетчик ссылок, что не занимает много времени. Глубокое копирование данных может занимать много времени. Используя `Rc::clone` для подсчета ссылок, можно визуально различать виды клонирования с глубоким копированием и клонирования, которые увеличивают количество ссылок. При поиске  в коде проблем с производительностью нужно рассмотреть только  клонирование с глубоким копированием и игнорировать вызовы `Rc::clone` .

### Клонирование `Rc<T>` увеличивает количество ссылок

Давайте изменим рабочий пример в листинге 15-18, чтобы увидеть как изменяется число ссылок при создании и удалении ссылок на `Rc<List>` внутри переменной `a`.

В листинге 15-19 мы изменим `main` так, чтобы она имела внутреннюю область видимости вокруг списка `c`; тогда мы сможем увидеть, как меняется счетчик ссылок при выходе `c` из внутренней области видимости.

<span class="filename">Файл: src/main.rs</span>

```rust
# enum List {
#     Cons(i32, Rc<List>),
#     Nil,
# }
#
# use crate::List::{Cons, Nil};
# use std::rc::Rc;
#
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```

<span class="caption">Листинг 15-19: Печать количества ссылок</span>

В каждой точке программы, где изменяется счетчик ссылок, мы печатаем значение счетчика, которое можно получить вызовом функции `Rc::strong_count`. Эта функция называется `strong_count`, а не `count`, потому что тип `Rc<T>` также имеет функцию `weak_count`; мы увидим, для чего используется `weak_count` в разделе <a href="ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt" data-md-type="link">«Предотвращение циклических ссылок: превращением `Rc<T>` в <code data-md-type="codespan">Weak<T></code>»</a><comment></comment>.

Код выводит в консоль:

```text
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
```

Можно увидеть, что `Rc<List>` в переменной `a` имеет начальный счетчик ссылок равный 1; затем каждый раз при вызове `clone` счетчик увеличивается на 1. Когда `c` выходит из области видимости, счетчик уменьшается на 1. Нам не нужно вызывать функцию уменьшения счетчика ссылок, как при вызове `Rc::clone` для увеличения счетчика ссылок: реализация `Drop` автоматически уменьшает счетчик ссылок, когда значение `Rc<T>` выходит из области видимости.

То чего мы не можем увидеть в этом примере является тем, что когда `b`, а затем `a` выходят из области видимости в конце функции `main`, счетчик становится равен 0 и `Rc<List>` полностью очищается в этом месте. Использование `Rc<T>` позволяет одному значению иметь нескольких владельцев, а подсчет ссылок гарантирует, что значение остается действительным до тех пор, пока существует любой из владельцев.

С помощью неизменяемых ссылок, тип `Rc<T>` позволяет обмениваться данными между несколькими частями вашей программы только для чтения данных. Если тип `Rc<T>` позволял бы иметь несколько изменяемых ссылок, вы могли бы нарушить одно из правил заимствования, описанных в главе 4: множественные изменяемые заимствования в одном и том же месте могут вызвать гонки данных (data races) и несогласованность данных. Но возможность изменять данные очень полезна! В следующем разделе мы обсудим шаблон внутренней изменчивости и тип `RefCell<T>`, который можно использовать вместе с `Rc<T>` для работы с этим ограничением.
